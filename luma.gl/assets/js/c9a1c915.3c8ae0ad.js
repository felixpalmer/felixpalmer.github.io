/*! For license information please see c9a1c915.3c8ae0ad.js.LICENSE.txt */
"use strict";(self.webpackChunkwebsite_docusaurus=self.webpackChunkwebsite_docusaurus||[]).push([[8403],{9301:(e,r,t)=>{t.r(r),t.d(r,{assets:()=>c,contentTitle:()=>i,default:()=>h,frontMatter:()=>d,metadata:()=>l,toc:()=>o});var s=t(4848),n=t(8453);const d={},i="Shader Transpilation",l={id:"api-guide/shaders/shader-transpilation",title:"Shader Transpilation",description:"From v9 luma.gl requires GLSL shaders to be written in GLSL 3.00 ES syntax.",source:"@site/../docs/api-guide/shaders/shader-transpilation.md",sourceDirName:"api-guide/shaders",slug:"/api-guide/shaders/shader-transpilation",permalink:"/luma.gl/docs/api-guide/shaders/shader-transpilation",draft:!1,unlisted:!1,editUrl:"https://github.com/visgl/luma.gl/tree/main/docs/../docs/api-guide/shaders/shader-transpilation.md",tags:[],version:"current",frontMatter:{},sidebar:"sidebar",previous:{title:"Shader Modules",permalink:"/luma.gl/docs/api-guide/shaders/shader-modules"},next:{title:"Using Transforms",permalink:"/luma.gl/docs/api-guide/engine/transforms"}},c={},o=[];function a(e){const r={blockquote:"blockquote",code:"code",h1:"h1",li:"li",p:"p",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,n.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(r.h1,{id:"shader-transpilation",children:"Shader Transpilation"}),"\n",(0,s.jsxs)(r.blockquote,{children:["\n",(0,s.jsx)(r.p,{children:"From v9 luma.gl requires GLSL shaders to be written in GLSL 3.00 ES syntax."}),"\n"]}),"\n",(0,s.jsxs)(r.p,{children:["If ",(0,s.jsx)(r.code,{children:"platformInfo"})," specifies that GLSL 1.0 is required by the ",(0,s.jsx)(r.code,{children:"Device"}),", ",(0,s.jsx)(r.code,{children:"assembleShaders"})," will attempt to transpile GLSL 3.0 shaders to GLSL ES 1.0."]}),"\n",(0,s.jsx)(r.p,{children:"This transpilation is a limited text replacement and requires that certain conventions be followed:"}),"\n",(0,s.jsxs)(r.ul,{children:["\n",(0,s.jsx)(r.li,{children:"Statements are written one per line."}),"\n",(0,s.jsx)(r.li,{children:"Only one fragment shader output is supported."}),"\n",(0,s.jsx)(r.li,{children:"GLSL 3.0-only features, such as 3D textures are not supported."}),"\n"]}),"\n",(0,s.jsx)(r.p,{children:"Text transformations are performed according to the following tables:"}),"\n",(0,s.jsx)(r.p,{children:"Vertex Shaders"}),"\n",(0,s.jsxs)(r.table,{children:[(0,s.jsx)(r.thead,{children:(0,s.jsxs)(r.tr,{children:[(0,s.jsx)(r.th,{children:"3.00 ES"}),(0,s.jsx)(r.th,{children:"1.00 ES"}),(0,s.jsx)(r.th,{children:"Comment"})]})}),(0,s.jsxs)(r.tbody,{children:[(0,s.jsxs)(r.tr,{children:[(0,s.jsx)(r.td,{children:(0,s.jsx)(r.code,{children:"in"})}),(0,s.jsx)(r.td,{children:(0,s.jsx)(r.code,{children:"attribute"})}),(0,s.jsx)(r.td,{})]}),(0,s.jsxs)(r.tr,{children:[(0,s.jsx)(r.td,{children:(0,s.jsx)(r.code,{children:"out"})}),(0,s.jsx)(r.td,{children:(0,s.jsx)(r.code,{children:"varying"})}),(0,s.jsx)(r.td,{})]})]})]}),"\n",(0,s.jsx)(r.p,{children:"Fragment Shaders"}),"\n",(0,s.jsxs)(r.table,{children:[(0,s.jsx)(r.thead,{children:(0,s.jsxs)(r.tr,{children:[(0,s.jsx)(r.th,{children:"3.00 ES"}),(0,s.jsx)(r.th,{children:"1.00 ES"}),(0,s.jsx)(r.th,{children:"Comment"})]})}),(0,s.jsxs)(r.tbody,{children:[(0,s.jsxs)(r.tr,{children:[(0,s.jsx)(r.td,{children:(0,s.jsx)(r.code,{children:"in"})}),(0,s.jsx)(r.td,{children:(0,s.jsx)(r.code,{children:"varying"})}),(0,s.jsx)(r.td,{})]}),(0,s.jsxs)(r.tr,{children:[(0,s.jsx)(r.td,{children:(0,s.jsx)(r.code,{children:"out vec4 <varName>"})}),(0,s.jsx)(r.td,{children:(0,s.jsx)(r.code,{children:"gl_FragColor"})}),(0,s.jsxs)(r.td,{children:[(0,s.jsx)(r.code,{children:"<varName>"})," declaration is removed and usage in the code are replaced with ",(0,s.jsx)(r.code,{children:"gl_FragColor"})]})]}),(0,s.jsxs)(r.tr,{children:[(0,s.jsx)(r.td,{children:(0,s.jsx)(r.code,{children:"texture"})}),(0,s.jsx)(r.td,{children:(0,s.jsx)(r.code,{children:"texture2D"})}),(0,s.jsxs)(r.td,{children:[(0,s.jsx)(r.code,{children:"texture"})," will be replaced with ",(0,s.jsx)(r.code,{children:"texture2D"})," to ensure 1.00 code is correct. See note on ",(0,s.jsx)(r.code,{children:"textureCube"})," below."]})]}),(0,s.jsxs)(r.tr,{children:[(0,s.jsxs)(r.td,{children:[(0,s.jsx)(r.code,{children:"textureCube"})," *"]}),(0,s.jsx)(r.td,{children:(0,s.jsx)(r.code,{children:"textureCube"})}),(0,s.jsxs)(r.td,{children:[(0,s.jsx)(r.code,{children:"textureCube"})," is not valid 3.00 syntax, but must be used to ensure 1.00 code is correct, because ",(0,s.jsx)(r.code,{children:"texture"})," will be substituted with ",(0,s.jsx)(r.code,{children:"texture2D"})," when transpiled to 100. Also ",(0,s.jsx)(r.code,{children:"textureCube"})," will be replaced with correct ",(0,s.jsx)(r.code,{children:"texture"})," syntax when transpiled to 300."]})]})]})]})]})}function h(e={}){const{wrapper:r}={...(0,n.R)(),...e.components};return r?(0,s.jsx)(r,{...e,children:(0,s.jsx)(a,{...e})}):a(e)}},1020:(e,r,t)=>{var s=t(6540),n=Symbol.for("react.element"),d=Symbol.for("react.fragment"),i=Object.prototype.hasOwnProperty,l=s.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner,c={key:!0,ref:!0,__self:!0,__source:!0};function o(e,r,t){var s,d={},o=null,a=null;for(s in void 0!==t&&(o=""+t),void 0!==r.key&&(o=""+r.key),void 0!==r.ref&&(a=r.ref),r)i.call(r,s)&&!c.hasOwnProperty(s)&&(d[s]=r[s]);if(e&&e.defaultProps)for(s in r=e.defaultProps)void 0===d[s]&&(d[s]=r[s]);return{$$typeof:n,type:e,key:o,ref:a,props:d,_owner:l.current}}r.Fragment=d,r.jsx=o,r.jsxs=o},4848:(e,r,t)=>{e.exports=t(1020)},8453:(e,r,t)=>{t.d(r,{R:()=>i,x:()=>l});var s=t(6540);const n={},d=s.createContext(n);function i(e){const r=s.useContext(d);return s.useMemo((function(){return"function"==typeof e?e(r):{...r,...e}}),[r,e])}function l(e){let r;return r=e.disableParentContext?"function"==typeof e.components?e.components(n):e.components||n:i(e.components),s.createElement(d.Provider,{value:r},e.children)}}}]);