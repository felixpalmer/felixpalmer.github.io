/*! For license information please see 1e546acc.c7c59429.js.LICENSE.txt */
"use strict";(self.webpackChunkwebsite_docusaurus=self.webpackChunkwebsite_docusaurus||[]).push([[7728],{463:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>l,contentTitle:()=>i,default:()=>h,frontMatter:()=>o,metadata:()=>a,toc:()=>t});var d=s(5893),r=s(1151);const o={},i="ShaderAssembler",a={id:"api-reference/shadertools/shader-assembler",title:"ShaderAssembler",description:"The functionality of the shadertools module shader system is primarily exposed",source:"@site/../docs/api-reference/shadertools/shader-assembler.md",sourceDirName:"api-reference/shadertools",slug:"/api-reference/shadertools/shader-assembler",permalink:"/luma.gl/docs/api-reference/shadertools/shader-assembler",draft:!1,unlisted:!1,editUrl:"https://github.com/visgl/luma.gl/tree/main/docs/../docs/api-reference/shadertools/shader-assembler.md",tags:[],version:"current",frontMatter:{},sidebar:"sidebar",previous:{title:"Overview",permalink:"/luma.gl/docs/api-reference/shadertools/"},next:{title:"Shader Parsing",permalink:"/luma.gl/docs/api-reference/shadertools/shader-info"}},l={},t=[{value:"Static Methods",id:"static-methods",level:2},{value:"<code>getDefaultShaderAssembler()</code>",id:"getdefaultshaderassembler",level:3},{value:"Methods",id:"methods",level:2},{value:"<code>addDefaultModule(module: ShaderModule)</code>",id:"adddefaultmodulemodule-shadermodule",level:3},{value:"<code>removeDefaultModule(module: ShaderModule)</code>",id:"removedefaultmodulemodule-shadermodule",level:3},{value:"<code>addShaderHook(hook: string, [opts: Object])</code>",id:"addshaderhookhook-string-opts-object",level:3},{value:"<code>assembleShaders</code>",id:"assembleshaders",level:3},{value:"Shader Module Assembly",id:"shader-module-assembly",level:2},{value:"Shader Hooks and Module Injections",id:"shader-hooks-and-module-injections",level:2},{value:"Constants and Values",id:"constants-and-values",level:2},{value:"Predefined Injection Hooks",id:"predefined-injection-hooks",level:3},{value:"Usage",id:"usage",level:2},{value:"Injection Map",id:"injection-map",level:3},{value:"Transpilation",id:"transpilation",level:2}];function c(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",li:"li",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,r.a)(),...e.components};return(0,d.jsxs)(d.Fragment,{children:[(0,d.jsx)(n.h1,{id:"shaderassembler",children:"ShaderAssembler"}),"\n",(0,d.jsxs)(n.p,{children:["The functionality of the ",(0,d.jsx)(n.code,{children:"shadertools"})," module shader system is primarily exposed\nvia the ",(0,d.jsx)(n.code,{children:"ShaderAssembler"})," class."]}),"\n",(0,d.jsxs)(n.p,{children:[(0,d.jsx)(n.code,{children:"shaderAssebler.assembleShaders()"})," composes base vertex and fragment shader source with"]}),"\n",(0,d.jsxs)(n.ul,{children:["\n",(0,d.jsx)(n.li,{children:"shader modules"}),"\n",(0,d.jsx)(n.li,{children:"hook functions"}),"\n",(0,d.jsx)(n.li,{children:"and injections\nto generate the final vertex and fragment shader source that can be used to create a program."}),"\n"]}),"\n",(0,d.jsx)(n.h2,{id:"static-methods",children:"Static Methods"}),"\n",(0,d.jsx)(n.h3,{id:"getdefaultshaderassembler",children:(0,d.jsx)(n.code,{children:"getDefaultShaderAssembler()"})}),"\n",(0,d.jsxs)(n.p,{children:["Most applications that register default modules and hooks will want to use a single ",(0,d.jsx)(n.code,{children:"Shader"})]}),"\n",(0,d.jsx)(n.h2,{id:"methods",children:"Methods"}),"\n",(0,d.jsx)(n.h3,{id:"adddefaultmodulemodule-shadermodule",children:(0,d.jsx)(n.code,{children:"addDefaultModule(module: ShaderModule)"})}),"\n",(0,d.jsx)(n.p,{children:"Add a module that will automatically be added to any programs created by the program manager."}),"\n",(0,d.jsx)(n.h3,{id:"removedefaultmodulemodule-shadermodule",children:(0,d.jsx)(n.code,{children:"removeDefaultModule(module: ShaderModule)"})}),"\n",(0,d.jsx)(n.p,{children:"Remove a module that is automatically being added to programs created by the program manager."}),"\n",(0,d.jsx)(n.h3,{id:"addshaderhookhook-string-opts-object",children:(0,d.jsx)(n.code,{children:"addShaderHook(hook: string, [opts: Object])"})}),"\n",(0,d.jsx)(n.p,{children:"Creates a shader hook function that shader modules can injection code into. Shaders can call these functions, which will be no-ops by default. If a shader module injects code it will be executed upon the hook function call. This mechanism allows the application to create shaders that can be automatically extended by included shader modules."}),"\n",(0,d.jsxs)(n.ul,{children:["\n",(0,d.jsxs)(n.li,{children:[(0,d.jsx)(n.code,{children:"hook"}),": ",(0,d.jsx)(n.code,{children:"vs:"})," or ",(0,d.jsx)(n.code,{children:"fs:"})," followed by the name and arguments of the function, e.g. ",(0,d.jsx)(n.code,{children:"vs:MYHOOK_func(inout vec4 value)"}),". Hook name without arguments\nwill also be used as the name of the shader hook"]}),"\n",(0,d.jsxs)(n.li,{children:[(0,d.jsx)(n.code,{children:"opts.header"})," (optional): code always included at the beginning of a hook function"]}),"\n",(0,d.jsxs)(n.li,{children:[(0,d.jsx)(n.code,{children:"opts.footer"})," (optional): code always included at the end of a hook function"]}),"\n"]}),"\n",(0,d.jsx)(n.h3,{id:"assembleshaders",children:(0,d.jsx)(n.code,{children:"assembleShaders"})}),"\n",(0,d.jsxs)(n.p,{children:[(0,d.jsx)(n.code,{children:"ahaderAssebler.assembleShaders()"})," composes base vertex and fragment shader source with shader modules,\nhook functions and injections to generate the final vertex and\nfragment shader source that can be used to create a program."]}),"\n",(0,d.jsx)(n.p,{children:"Takes the source code of a vertex shader and a fragment shader, and a list of modules, defines, etc. Outputs resolved source code for both shaders, after adding prologue, adding defines, importing and transpiling modules, and injecting any shader fragments)."}),"\n",(0,d.jsxs)(n.ul,{children:["\n",(0,d.jsxs)(n.li,{children:[(0,d.jsx)(n.code,{children:"vs"})," - vertex shader source"]}),"\n",(0,d.jsxs)(n.li,{children:[(0,d.jsx)(n.code,{children:"fs"})," - fragment shader source code"]}),"\n",(0,d.jsxs)(n.li,{children:[(0,d.jsx)(n.code,{children:"id"})," - ",(0,d.jsx)(n.code,{children:"id"})," for the shader, will be used to inject shader names (using ",(0,d.jsx)(n.code,{children:"#define SHADER_NAME"}),") if not already present in the source."]}),"\n",(0,d.jsxs)(n.li,{children:[(0,d.jsx)(n.code,{children:"prologue"}),"=",(0,d.jsx)(n.code,{children:"true"})," (Boolean) - Will inject platform prologue (see below)"]}),"\n",(0,d.jsxs)(n.li,{children:[(0,d.jsx)(n.code,{children:"defines"}),"=",(0,d.jsx)(n.code,{children:"{}"})," (Object) - a map of key/value pairs representing custom ",(0,d.jsx)(n.code,{children:"#define"}),"s to be injected into the shader source"]}),"\n",(0,d.jsxs)(n.li,{children:[(0,d.jsx)(n.code,{children:"modules"}),"=",(0,d.jsx)(n.code,{children:"[]"})," (Array) - list of shader modules (either objects defining the module, or names of previously registered modules)"]}),"\n",(0,d.jsxs)(n.li,{children:[(0,d.jsx)(n.code,{children:"inject"}),"=",(0,d.jsx)(n.code,{children:"{}"})," (Object) - map of substituions,"]}),"\n",(0,d.jsxs)(n.li,{children:[(0,d.jsx)(n.code,{children:"hookFunctions"}),"=",(0,d.jsx)(n.code,{children:"[]"})," Array of hook functions descriptions. Descriptions can simply be the hook function signature (with a prefix ",(0,d.jsx)(n.code,{children:"vs"})," for vertex shader, or ",(0,d.jsx)(n.code,{children:"fs"})," for fragment shader) or an object with the hook signature, and a header and footer that will always appear in the hook function. For example:"]}),"\n"]}),"\n",(0,d.jsx)(n.pre,{children:(0,d.jsx)(n.code,{className:"language-typescript",children:"[\n  'vs:MY_HOOK_FUNCTION1(inout vec4 color)',\n  {\n    hook: 'fs:MY_HOOK_FUNCTION2(inout vec4 color)',\n    header: 'if (color.a == 0.0) discard;\\n',\n    footer: 'color.a *= 1.2;\\n'\n  }\n];\n"})}),"\n",(0,d.jsx)(n.p,{children:"Returns:"}),"\n",(0,d.jsxs)(n.ul,{children:["\n",(0,d.jsxs)(n.li,{children:[(0,d.jsx)(n.code,{children:"vs"})," - the resolved vertex shader"]}),"\n",(0,d.jsxs)(n.li,{children:[(0,d.jsx)(n.code,{children:"fs"})," - the resolved fragment shader"]}),"\n",(0,d.jsxs)(n.li,{children:[(0,d.jsx)(n.code,{children:"getUniforms"})," - a combined ",(0,d.jsx)(n.code,{children:"getUniforms"})," function covering all modules."]}),"\n",(0,d.jsxs)(n.li,{children:[(0,d.jsx)(n.code,{children:"moduleMap"})," - a map with all resolved modules, keyed by name"]}),"\n"]}),"\n",(0,d.jsx)(n.h2,{id:"shader-module-assembly",children:"Shader Module Assembly"}),"\n",(0,d.jsxs)(n.p,{children:["luma.gl's module shader system is primarily exposed via the function ",(0,d.jsx)(n.code,{children:"assembleShaders"})," which composes base vertex and fragment shader source with shader modules, hook functions and injections to generate the final vertex and fragment shader source that can be used to create a program."]}),"\n",(0,d.jsx)(n.h2,{id:"shader-hooks-and-module-injections",children:"Shader Hooks and Module Injections"}),"\n",(0,d.jsxs)(n.p,{children:["Shader hooks and module injections are a system that allows for shader to be written in a generic manner, with behaviour modified when modules are included. For example if we define a shader hook as ",(0,d.jsx)(n.code,{children:"fs:MY_HOOK_FUNCTION(inout vec4 color)"}),", ",(0,d.jsx)(n.code,{children:"assembleShader"})," will inject the following function automatically into our fragment shader:"]}),"\n",(0,d.jsx)(n.pre,{children:(0,d.jsx)(n.code,{className:"language-c",children:"void MY_HOOK_FUNCTION(inout vec4 color) {\n\n}\n"})}),"\n",(0,d.jsx)(n.p,{children:"We can the write our fragment shader as follows:"}),"\n",(0,d.jsx)(n.pre,{children:(0,d.jsx)(n.code,{className:"language-c",children:"precision highp float;\n\nvoid main() {\n  vec4 color = vec4(1.0);\n  gl_FragColor = MY_HOOK_FUNCTION(color)\n}\n"})}),"\n",(0,d.jsx)(n.p,{children:"By default, the hook function is a no-op, so this doesn't do anything. However, if we add a module injection like the following:"}),"\n",(0,d.jsx)(n.pre,{children:(0,d.jsx)(n.code,{className:"language-typescript",children:"{\n  picking: {\n    'fs:VERTEX_HOOK_FUNCTION': 'color = vec4(1.0, 0.0, 0.0, 1.0);'\n  }\n}\n"})}),"\n",(0,d.jsxs)(n.p,{children:["And pass the ",(0,d.jsx)(n.code,{children:"picking"})," module to ",(0,d.jsx)(n.code,{children:"assembledShaders"}),", the hook function will be updated as follows:"]}),"\n",(0,d.jsx)(n.pre,{children:(0,d.jsx)(n.code,{className:"language-c",children:"void MY_HOOK_FUNCTION(inout vec4 color) {\n  color = vec4(1.0, 0.0, 0.0, 1.0);\n}\n"})}),"\n",(0,d.jsx)(n.p,{children:"The hook function now changes the color from white to red."}),"\n",(0,d.jsx)(n.h2,{id:"constants-and-values",children:"Constants and Values"}),"\n",(0,d.jsx)(n.h3,{id:"predefined-injection-hooks",children:"Predefined Injection Hooks"}),"\n",(0,d.jsxs)(n.table,{children:[(0,d.jsx)(n.thead,{children:(0,d.jsxs)(n.tr,{children:[(0,d.jsx)(n.th,{children:"Key"}),(0,d.jsx)(n.th,{children:"Shader"}),(0,d.jsx)(n.th,{children:"Description"})]})}),(0,d.jsxs)(n.tbody,{children:[(0,d.jsxs)(n.tr,{children:[(0,d.jsx)(n.td,{children:(0,d.jsx)(n.code,{children:"vs:#decl"})}),(0,d.jsx)(n.td,{children:"Vertex"}),(0,d.jsx)(n.td,{children:"Inject at top of shader (declarations)"})]}),(0,d.jsxs)(n.tr,{children:[(0,d.jsx)(n.td,{children:(0,d.jsx)(n.code,{children:"vs:#main-start"})}),(0,d.jsx)(n.td,{children:"Vertex"}),(0,d.jsx)(n.td,{children:"Injected at the very beginning of main function"})]}),(0,d.jsxs)(n.tr,{children:[(0,d.jsx)(n.td,{children:(0,d.jsx)(n.code,{children:"vs:#main-end"})}),(0,d.jsx)(n.td,{children:"Vertex"}),(0,d.jsx)(n.td,{children:"Injected at the very end of main function"})]}),(0,d.jsxs)(n.tr,{children:[(0,d.jsx)(n.td,{children:(0,d.jsx)(n.code,{children:"fs:#decl"})}),(0,d.jsx)(n.td,{children:"Fragment"}),(0,d.jsx)(n.td,{children:"Inject at top of shader (declarations)"})]}),(0,d.jsxs)(n.tr,{children:[(0,d.jsx)(n.td,{children:(0,d.jsx)(n.code,{children:"fs:#main-start"})}),(0,d.jsx)(n.td,{children:"Fragment"}),(0,d.jsx)(n.td,{children:"Injected at the very beginning of main function"})]}),(0,d.jsxs)(n.tr,{children:[(0,d.jsx)(n.td,{children:(0,d.jsx)(n.code,{children:"fs:#main-end"})}),(0,d.jsx)(n.td,{children:"Fragment"}),(0,d.jsx)(n.td,{children:"Injected at the very end of main function"})]})]})]}),"\n",(0,d.jsxs)(n.p,{children:[(0,d.jsx)(n.strong,{children:"NOTE"}),": Injections assume that the ",(0,d.jsx)(n.code,{children:"main"})," function appears last in a shader."]}),"\n",(0,d.jsx)(n.h2,{id:"usage",children:"Usage"}),"\n",(0,d.jsx)(n.h3,{id:"injection-map",children:"Injection Map"}),"\n",(0,d.jsxs)(n.p,{children:[(0,d.jsx)(n.code,{children:"assembleShaders"})," (and ",(0,d.jsx)(n.code,{children:"Model"})," constructor) will take an ",(0,d.jsx)(n.code,{children:"inject"})," argument that contains a map of:"]}),"\n",(0,d.jsxs)(n.ul,{children:["\n",(0,d.jsx)(n.li,{children:"keys indicating hooks (predefined or functions)"}),"\n",(0,d.jsxs)(n.li,{children:["values representing code to be injected. This can be either a simple string or an object containing the ",(0,d.jsx)(n.code,{children:"injection"})," string and an ",(0,d.jsx)(n.code,{children:"order"})," indicating its priority."]}),"\n"]}),"\n",(0,d.jsx)(n.p,{children:"Examples:"}),"\n",(0,d.jsx)(n.pre,{children:(0,d.jsx)(n.code,{children:"  inject: {\n    'fs:#main-end': '  gl_FragColor = picking_filterColor(gl_FragColor)'\n  }\n"})}),"\n",(0,d.jsx)(n.pre,{children:(0,d.jsx)(n.code,{className:"language-typescript",children:"ProgramManager.getDefaultProgramManager(gl).addShaderHook('fs:MYHOOK_fragmentColor(inout vec4 color)');\n\nnew Model(gl, {\n  vs,\n  fs: `void main() {\n    MYHOOK_fragmentColor(gl_FragColor);\n  }`,\n  modules: [picking]\n  inject: {\n    'fs:#main-start': 'gl_FragColor = vec4(1., 0., 0., 1.);';\n    'fs:MYHOOK_fragmentColor': {\n      injection: '  color = picking_filterColor(color);',\n      order: 9999\n  }\n});\n"})}),"\n",(0,d.jsx)(n.h2,{id:"transpilation",children:"Transpilation"}),"\n",(0,d.jsxs)(n.p,{children:["If the platformInfo specifies that GLSL 1.0 is required, ",(0,d.jsx)(n.code,{children:"assembleShaders"})," will attempt to transpile GLSL 3.0 shaders to GLSL ES 1.0."]}),"\n",(0,d.jsx)(n.p,{children:"See the user guide for more details."})]})}function h(e={}){const{wrapper:n}={...(0,r.a)(),...e.components};return n?(0,d.jsx)(n,{...e,children:(0,d.jsx)(c,{...e})}):c(e)}},5251:(e,n,s)=>{var d=s(7294),r=Symbol.for("react.element"),o=Symbol.for("react.fragment"),i=Object.prototype.hasOwnProperty,a=d.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner,l={key:!0,ref:!0,__self:!0,__source:!0};function t(e,n,s){var d,o={},t=null,c=null;for(d in void 0!==s&&(t=""+s),void 0!==n.key&&(t=""+n.key),void 0!==n.ref&&(c=n.ref),n)i.call(n,d)&&!l.hasOwnProperty(d)&&(o[d]=n[d]);if(e&&e.defaultProps)for(d in n=e.defaultProps)void 0===o[d]&&(o[d]=n[d]);return{$$typeof:r,type:e,key:t,ref:c,props:o,_owner:a.current}}n.Fragment=o,n.jsx=t,n.jsxs=t},5893:(e,n,s)=>{e.exports=s(5251)},1151:(e,n,s)=>{s.d(n,{Z:()=>a,a:()=>i});var d=s(7294);const r={},o=d.createContext(r);function i(e){const n=d.useContext(o);return d.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:i(e.components),d.createElement(o.Provider,{value:n},e.children)}}}]);