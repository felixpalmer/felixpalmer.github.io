"use strict";(self.webpackChunkwebsite_docusaurus=self.webpackChunkwebsite_docusaurus||[]).push([[53],{1109:e=>{e.exports=JSON.parse('{"pluginId":"default","version":"current","label":"Next","banner":null,"badge":false,"noIndex":false,"className":"docs-version-current","isLast":true,"docsSidebars":{"sidebar":[{"type":"link","label":"Overview","href":"/luma.gl/docs/","docId":"README","unlisted":false},{"type":"link","label":"What\'s New","href":"/luma.gl/docs/whats-new","docId":"whats-new","unlisted":false},{"type":"category","label":"Tutorials","items":[{"type":"link","label":"Setup","href":"/luma.gl/docs/tutorials/","docId":"tutorials/README","unlisted":false},{"type":"link","label":"Hello Triangle","href":"/luma.gl/docs/tutorials/hello-triangle","docId":"tutorials/hello-triangle","unlisted":false},{"type":"link","label":"Hello Cube","href":"/luma.gl/docs/tutorials/hello-cube","docId":"tutorials/hello-cube","unlisted":false},{"type":"link","label":"Lighting","href":"/luma.gl/docs/tutorials/lighting","docId":"tutorials/lighting","unlisted":false},{"type":"link","label":"Hello Instancing","href":"/luma.gl/docs/tutorials/hello-instancing","docId":"tutorials/hello-instancing","unlisted":false},{"type":"link","label":"Shader Modules","href":"/luma.gl/docs/tutorials/shader-modules","docId":"tutorials/shader-modules","unlisted":false},{"type":"link","label":"Shader Hooks","href":"/luma.gl/docs/tutorials/shader-hooks","docId":"tutorials/shader-hooks","unlisted":false},{"type":"link","label":"Transform","href":"/luma.gl/docs/tutorials/transform","docId":"tutorials/transform","unlisted":false},{"type":"link","label":"Transform Feedback","href":"/luma.gl/docs/tutorials/transform-feedback","docId":"tutorials/transform-feedback","unlisted":false},{"type":"link","label":"Instanced Transform","href":"/luma.gl/docs/tutorials/instanced-transform","docId":"tutorials/instanced-transform","unlisted":false},{"type":"link","label":"External WebGL Contexts","href":"/luma.gl/docs/tutorials/external-context","docId":"tutorials/external-context","unlisted":false},{"type":"link","label":"What\'s Next?","href":"/luma.gl/docs/tutorials/whats-next","docId":"tutorials/whats-next","unlisted":false}],"collapsed":true,"collapsible":true},{"type":"category","label":"API Guide","items":[{"type":"category","label":"Background","items":[{"type":"link","label":"API Design Philosophy","href":"/luma.gl/docs/api-guide/background/api-design","docId":"api-guide/background/api-design","unlisted":false},{"type":"link","label":"Learning Resources","href":"/luma.gl/docs/api-guide/background/learning-resources","docId":"api-guide/background/learning-resources","unlisted":false},{"type":"link","label":"WebGPU vs WebGL","href":"/luma.gl/docs/api-guide/background/webgpu-vs-webgl","docId":"api-guide/background/webgpu-vs-webgl","unlisted":false}],"collapsed":true,"collapsible":true},{"type":"link","label":"API Overview","href":"/luma.gl/docs/api-guide/","docId":"api-guide/README","unlisted":false},{"type":"link","label":"GPU Access","href":"/luma.gl/docs/api-guide/device","docId":"api-guide/device","unlisted":false},{"type":"link","label":"GPU Resources","href":"/luma.gl/docs/api-guide/resources","docId":"api-guide/resources","unlisted":false},{"type":"link","label":"GPU Memory Management","href":"/luma.gl/docs/api-guide/memory","docId":"api-guide/memory","unlisted":false},{"type":"link","label":"Using GPU Buffers","href":"/luma.gl/docs/api-guide/buffers","docId":"api-guide/buffers","unlisted":false},{"type":"link","label":"Using GPU Textures","href":"/luma.gl/docs/api-guide/textures","docId":"api-guide/textures","unlisted":false},{"type":"link","label":"How Rendering Works","href":"/luma.gl/docs/api-guide/rendering","docId":"api-guide/rendering","unlisted":false},{"type":"link","label":"Using GPU Parameters","href":"/luma.gl/docs/api-guide/parameters","docId":"api-guide/parameters","unlisted":false},{"type":"link","label":"Understanding Bindings","href":"/luma.gl/docs/api-guide/bindings","docId":"api-guide/bindings","unlisted":false},{"type":"link","label":"Attributes","href":"/luma.gl/docs/api-guide/attributes","docId":"api-guide/attributes","unlisted":false},{"type":"link","label":"Uniforms","href":"/luma.gl/docs/api-guide/uniforms","docId":"api-guide/uniforms","unlisted":false},{"type":"link","label":"Using Transforms","href":"/luma.gl/docs/api-guide/transforms","docId":"api-guide/transforms","unlisted":false},{"type":"link","label":"Shader Modules","href":"/luma.gl/docs/api-guide/shader-modules","docId":"api-guide/shader-modules","unlisted":false}],"collapsed":true,"collapsible":true},{"type":"category","label":"API Reference","items":[{"type":"link","label":"Overview","href":"/luma.gl/docs/api-reference/","docId":"api-reference/README","unlisted":false},{"type":"category","label":"@luma.gl/core","items":[{"type":"link","label":"Overview","href":"/luma.gl/docs/api-reference/core/","docId":"api-reference/core/README","unlisted":false},{"type":"link","label":"Device","href":"/luma.gl/docs/api-reference/core/device","docId":"api-reference/core/device","unlisted":false},{"type":"link","label":"DeviceFeature","href":"/luma.gl/docs/api-reference/core/device-features","docId":"api-reference/core/device-features","unlisted":false},{"type":"link","label":"DeviceLimits","href":"/luma.gl/docs/api-reference/core/device-limits","docId":"api-reference/core/device-limits","unlisted":false},{"type":"link","label":"CanvasContext","href":"/luma.gl/docs/api-reference/core/canvas-context","docId":"api-reference/core/canvas-context","unlisted":false},{"type":"link","label":"GPU Parameters","href":"/luma.gl/docs/api-reference/core/parameters","docId":"api-reference/core/parameters","unlisted":false},{"type":"link","label":"Bindings","href":"/luma.gl/docs/api-reference/core/bindings","docId":"api-reference/core/bindings","unlisted":false},{"type":"link","label":"ShaderLayout","href":"/luma.gl/docs/api-reference/core/shader-layout","docId":"api-reference/core/shader-layout","unlisted":false},{"type":"link","label":"Texture Formats","href":"/luma.gl/docs/api-reference/core/texture-formats","docId":"api-reference/core/texture-formats","unlisted":false},{"type":"link","label":"Buffer","href":"/luma.gl/docs/api-reference/core/resources/buffer","docId":"api-reference/core/resources/buffer","unlisted":false},{"type":"link","label":"ComputePipeline","href":"/luma.gl/docs/api-reference/core/resources/compute-pipeline","docId":"api-reference/core/resources/compute-pipeline","unlisted":false},{"type":"link","label":"Framebuffer","href":"/luma.gl/docs/api-reference/core/resources/framebuffer","docId":"api-reference/core/resources/framebuffer","unlisted":false},{"type":"link","label":"RenderPipeline","href":"/luma.gl/docs/api-reference/core/resources/render-pipeline","docId":"api-reference/core/resources/render-pipeline","unlisted":false},{"type":"link","label":"Sampler","href":"/luma.gl/docs/api-reference/core/resources/sampler","docId":"api-reference/core/resources/sampler","unlisted":false},{"type":"link","label":"Shader","href":"/luma.gl/docs/api-reference/core/resources/shader","docId":"api-reference/core/resources/shader","unlisted":false},{"type":"link","label":"Shader Logs","href":"/luma.gl/docs/api-reference/core/shader-logs","docId":"api-reference/core/shader-logs","unlisted":false},{"type":"link","label":"Texture","href":"/luma.gl/docs/api-reference/core/resources/texture","docId":"api-reference/core/resources/texture","unlisted":false},{"type":"link","label":"VertexArray","href":"/luma.gl/docs/api-reference/core/resources/vertex-array","docId":"api-reference/core/resources/vertex-array","unlisted":false}],"collapsed":true,"collapsible":true},{"type":"category","label":"@luma.gl/core","items":[{"type":"link","label":"Overview","href":"/luma.gl/docs/api-reference/core/","docId":"api-reference/core/README","unlisted":false}],"collapsed":true,"collapsible":true},{"type":"category","label":"@luma.gl/engine","items":[{"type":"link","label":"AnimationLoop","href":"/luma.gl/docs/api-reference/engine/animation-loop","docId":"api-reference/engine/animation-loop","unlisted":false},{"type":"link","label":"AnimationLoopTemplate","href":"/luma.gl/docs/api-reference/engine/animation-loop-template","docId":"api-reference/engine/animation-loop-template","unlisted":false},{"type":"link","label":"KeyFrames","href":"/luma.gl/docs/api-reference/engine/animation/key-frames","docId":"api-reference/engine/animation/key-frames","unlisted":false},{"type":"link","label":"Timeline","href":"/luma.gl/docs/api-reference/engine/animation/timeline","docId":"api-reference/engine/animation/timeline","unlisted":false},{"type":"link","label":"Built-in Geometries","href":"/luma.gl/docs/api-reference/engine/geometry/geometries","docId":"api-reference/engine/geometry/geometries","unlisted":false},{"type":"link","label":"Geometry","href":"/luma.gl/docs/api-reference/engine/geometry/","docId":"api-reference/engine/geometry/geometry","unlisted":false},{"type":"link","label":"Model","href":"/luma.gl/docs/api-reference/engine/model","docId":"api-reference/engine/model","unlisted":false},{"type":"link","label":"PipelineFactory","href":"/luma.gl/docs/api-reference/engine/pipeline-factory","docId":"api-reference/engine/pipeline-factory","unlisted":false},{"type":"link","label":"Transform","href":"/luma.gl/docs/api-reference/engine/transform","docId":"api-reference/engine/transform","unlisted":false},{"type":"link","label":"BufferTransform","href":"/luma.gl/docs/api-reference/engine/transform/buffer-transform","docId":"api-reference/engine/transform/buffer-transform","unlisted":false},{"type":"link","label":"TextureTransform","href":"/luma.gl/docs/api-reference/engine/transform/texture-transform","docId":"api-reference/engine/transform/texture-transform","unlisted":false},{"type":"link","label":"GroupNode","href":"/luma.gl/docs/api-reference/engine/scenegraph/group-node","docId":"api-reference/engine/scenegraph/group-node","unlisted":false},{"type":"link","label":"ModelNode","href":"/luma.gl/docs/api-reference/engine/scenegraph/model-node","docId":"api-reference/engine/scenegraph/model-node","unlisted":false},{"type":"link","label":"ScenegraphNode","href":"/luma.gl/docs/api-reference/engine/scenegraph/scenegraph-node","docId":"api-reference/engine/scenegraph/scenegraph-node","unlisted":false},{"type":"link","label":"GPUPointInPolygon","href":"/luma.gl/docs/api-reference/engine/gpgpu/gpu-point-in-polygon","docId":"api-reference/engine/gpgpu/gpu-point-in-polygon","unlisted":false},{"type":"link","label":"Histopyramid","href":"/luma.gl/docs/api-reference/engine/gpgpu/histopyramid","docId":"api-reference/engine/gpgpu/histopyramid","unlisted":false}],"collapsed":true,"collapsible":true},{"type":"category","label":"@luma.gl/gltf","items":[{"type":"link","label":"gltf","href":"/luma.gl/docs/api-reference/gltf/","docId":"api-reference/gltf/README","unlisted":false}],"collapsed":true,"collapsible":true},{"type":"category","label":"@luma.gl/shadertools","items":[{"type":"category","label":"Shader Modules","items":[{"type":"link","label":"Shader Modules","href":"/luma.gl/docs/api-reference/shadertools/shader-modules","docId":"api-reference/shadertools/shader-modules","unlisted":false},{"type":"link","label":"fp32 (32-bit Floating Point)","href":"/luma.gl/docs/api-reference/shadertools/shader-modules/fp32","docId":"api-reference/shadertools/shader-modules/fp32","unlisted":false},{"type":"link","label":"fp64 (64-bit Floating Point)","href":"/luma.gl/docs/api-reference/shadertools/shader-modules/fp64","docId":"api-reference/shadertools/shader-modules/fp64","unlisted":false},{"type":"link","label":"pbrMaterial","href":"/luma.gl/docs/api-reference/shadertools/shader-modules/pbr-material","docId":"api-reference/shadertools/shader-modules/pbr-material","unlisted":false},{"type":"link","label":"phongMaterial","href":"/luma.gl/docs/api-reference/shadertools/shader-modules/phong-material","docId":"api-reference/shadertools/shader-modules/phong-material","unlisted":false},{"type":"link","label":"gouraudMaterial","href":"/luma.gl/docs/api-reference/shadertools/shader-modules/gouraud-material","docId":"api-reference/shadertools/shader-modules/gouraud-material","unlisted":false},{"type":"link","label":"picking","href":"/luma.gl/docs/api-reference/shadertools/shader-modules/picking","docId":"api-reference/shadertools/shader-modules/picking","unlisted":false},{"type":"link","label":"project","href":"/luma.gl/docs/api-reference/shadertools/shader-modules/project","docId":"api-reference/shadertools/shader-modules/project","unlisted":false}],"collapsed":true,"collapsible":true},{"type":"category","label":"Shader Passes","items":[{"type":"link","label":"Image Processing","href":"/luma.gl/docs/api-reference/shadertools/shader-passes/image-processing","docId":"api-reference/shadertools/shader-passes/image-processing","unlisted":false}],"collapsed":true,"collapsible":true},{"type":"link","label":"Overview","href":"/luma.gl/docs/api-reference/shadertools/","docId":"api-reference/shadertools/README","unlisted":false},{"type":"link","label":"ShaderAssembler","href":"/luma.gl/docs/api-reference/shadertools/shader-assembler","docId":"api-reference/shadertools/shader-assembler","unlisted":false},{"type":"link","label":"Shader Parsing","href":"/luma.gl/docs/api-reference/shadertools/shader-info","docId":"api-reference/shadertools/shader-info","unlisted":false}],"collapsed":true,"collapsible":true},{"type":"category","label":"@luma.gl/test-utils","items":[{"type":"link","label":"Overview","href":"/luma.gl/docs/api-reference/test-utils/","docId":"api-reference/test-utils/README","unlisted":false},{"type":"link","label":"SnapshotTestRunner","href":"/luma.gl/docs/api-reference/test-utils/snapshot-test-runner","docId":"api-reference/test-utils/snapshot-test-runner","unlisted":false}],"collapsed":true,"collapsible":true},{"type":"category","label":"@luma.gl/webgl","items":[{"type":"link","label":"@luma.gl/webgl","href":"/luma.gl/docs/api-reference/webgl/","docId":"api-reference/webgl/README","unlisted":false}],"collapsed":true,"collapsible":true},{"type":"category","label":"@luma.gl/webgpu","items":[{"type":"link","label":"Overview","href":"/luma.gl/docs/api-reference/webgpu/","docId":"api-reference/webgpu/README","unlisted":false}],"collapsed":true,"collapsible":true}],"collapsed":true,"collapsible":true},{"type":"category","label":"Developer Guide","items":[{"type":"link","label":"Developer Guide","href":"/luma.gl/docs/developer-guide/","docId":"developer-guide/README","unlisted":false},{"type":"link","label":"Installing","href":"/luma.gl/docs/developer-guide/installing","docId":"developer-guide/installing","unlisted":false},{"type":"link","label":"Debugging","href":"/luma.gl/docs/developer-guide/debugging","docId":"developer-guide/debugging","unlisted":false},{"type":"link","label":"Testing","href":"/luma.gl/docs/developer-guide/testing","docId":"developer-guide/testing","unlisted":false},{"type":"link","label":"Profiling","href":"/luma.gl/docs/developer-guide/profiling","docId":"developer-guide/profiling","unlisted":false},{"type":"link","label":"Bundling","href":"/luma.gl/docs/developer-guide/bundling","docId":"developer-guide/bundling","unlisted":false},{"type":"link","label":"Contributing","href":"/luma.gl/docs/developer-guide/contributing","docId":"developer-guide/contributing","unlisted":false}],"collapsed":true,"collapsible":true},{"type":"category","label":"Upgrade Guide","items":[{"type":"link","label":"Upgrade Guide","href":"/luma.gl/docs/upgrade-guide/","docId":"upgrade-guide/README","unlisted":false},{"type":"link","label":"Porting Guide","href":"/luma.gl/docs/upgrade-guide/porting-guide","docId":"upgrade-guide/porting-guide","unlisted":false},{"type":"link","label":"Legacy Upgrade Guide","href":"/luma.gl/docs/upgrade-guide/legacy-guide","docId":"upgrade-guide/legacy-guide","unlisted":false}],"collapsed":true,"collapsible":true}]},"docs":{"api-guide/attributes":{"id":"api-guide/attributes","title":"Attributes","description":"In traditional 3D graphics, the purpose of GPU attributes* is to","sidebar":"sidebar"},"api-guide/background/api-design":{"id":"api-guide/background/api-design","title":"API Design Philosophy","description":"This article provides some background on luma.gl\'s API design philosophy.","sidebar":"sidebar"},"api-guide/background/learning-resources":{"id":"api-guide/background/learning-resources","title":"Learning Resources","description":"WebGPU","sidebar":"sidebar"},"api-guide/background/webgpu-vs-webgl":{"id":"api-guide/background/webgpu-vs-webgl","title":"WebGPU vs WebGL","description":"This page is a collection of developer notes on the differences between WebGPU and WebGL.","sidebar":"sidebar"},"api-guide/bindings":{"id":"api-guide/bindings","title":"Understanding Bindings","description":"luma.gl offers support for setting up (\\"binding\\") data required by the GPU during shader execution, including:","sidebar":"sidebar"},"api-guide/buffers":{"id":"api-guide/buffers","title":"Using GPU Buffers","description":"Buffer Operations","sidebar":"sidebar"},"api-guide/device":{"id":"api-guide/device","title":"GPU Access","description":"Device","sidebar":"sidebar"},"api-guide/memory":{"id":"api-guide/memory","title":"GPU Memory Management","description":"Memory on GPU is managed through Buffer and Texture resources.","sidebar":"sidebar"},"api-guide/parameters":{"id":"api-guide/parameters","title":"Using GPU Parameters","description":"luma.gl provides a unified API for controlling GPU parameters providing control of GPU pipeline features such as culling, depth and stencil buffers, blending, clipping etc.","sidebar":"sidebar"},"api-guide/README":{"id":"api-guide/README","title":"API Overview","description":"The luma.gl API is designed to expose the capabilities of the GPU and shader programming to web applications.","sidebar":"sidebar"},"api-guide/rendering":{"id":"api-guide/rendering","title":"How Rendering Works","description":"This page is a work-in-progress","sidebar":"sidebar"},"api-guide/resources":{"id":"api-guide/resources","title":"GPU Resources","description":"A key role of the Device class is to let the application create GPU resources.","sidebar":"sidebar"},"api-guide/shader-modules":{"id":"api-guide/shader-modules","title":"Shader Modules","description":"luma.device provides a GLSL shader module system (through the @luma.device/shadertools module) that allows you build modular shaders. The system is built around a GLSL \\"assembler\\", and addresses the lack of a module/import system in the GLSL language. The shader assembler allows you to import chunks of reusable shader code from separately defined shader fragments into your shader program source code, which allows you to organize your shader code in reusable modules.","sidebar":"sidebar"},"api-guide/shader-transpilation":{"id":"api-guide/shader-transpilation","title":"Shader Transpilation","description":"From v9 luma.gl requires GLSL shaders to be written in GLSL 3.00 ES syntax."},"api-guide/textures":{"id":"api-guide/textures","title":"Using GPU Textures","description":"Texture Dimension","sidebar":"sidebar"},"api-guide/transforms":{"id":"api-guide/transforms","title":"Using Transforms","description":"Note this documentation has not yet been updated to the luma.gl v9 API","sidebar":"sidebar"},"api-guide/uniforms":{"id":"api-guide/uniforms","title":"Uniforms","description":"Uniforms are shader variables whose values can be set from JavaScript.","sidebar":"sidebar"},"api-guide/vertex-array":{"id":"api-guide/vertex-array","title":"VertexArray","description":"Unless you are writing framework level code, it is usually not necessary to create VertexArray instances in luma.gl applications. It is often simpler to just provides attributes directly to the Model class. Still, it can be useful to review this documentation to understand how attributes are handled by luma.gl under the hood."},"api-reference/core/bindings":{"id":"api-reference/core/bindings","title":"Bindings","description":"A key responsibility of any GPU API is to enable the application to","sidebar":"sidebar"},"api-reference/core/buffer-layout":{"id":"api-reference/core/buffer-layout","title":"BufferLayout","description":"The bufferLayout type provides information about how the application is planning to"},"api-reference/core/canvas-context":{"id":"api-reference/core/canvas-context","title":"CanvasContext","description":"A CanvasContext holds a connection between a GPU Device and an HTML canvas or OffscreenCanvas into which it can render.","sidebar":"sidebar"},"api-reference/core/device":{"id":"api-reference/core/device","title":"Device","description":"The Device class manages the application\'s connection with the GPU,","sidebar":"sidebar"},"api-reference/core/device-features":{"id":"api-reference/core/device-features","title":"DeviceFeature","description":"The luma.gl Device provides a range of fields and functions to help an application","sidebar":"sidebar"},"api-reference/core/device-limits":{"id":"api-reference/core/device-limits","title":"DeviceLimits","description":"The device.limits field contains limits object that indicates what the current platform supports.","sidebar":"sidebar"},"api-reference/core/parameters":{"id":"api-reference/core/parameters","title":"GPU Parameters","description":"GPU parameters provide control of GPU pipeline features such as culling, depth and stencil buffers, blending, clipping etc.","sidebar":"sidebar"},"api-reference/core/README":{"id":"api-reference/core/README","title":"Overview","description":"The @luma.gl/core module provides an abstract API that enables application code","sidebar":"sidebar"},"api-reference/core/resources/buffer":{"id":"api-reference/core/resources/buffer","title":"Buffer","description":"Holds a block of GPU memory. The length of a buffer cannot be changed after creation.","sidebar":"sidebar"},"api-reference/core/resources/command-encoder":{"id":"api-reference/core/resources/command-encoder","title":"CommandEncoder","description":"A command encoder offering GPU memory copying operations."},"api-reference/core/resources/compute-pass":{"id":"api-reference/core/resources/compute-pass","title":"ComputePass","description":"WebGPU only"},"api-reference/core/resources/compute-pipeline":{"id":"api-reference/core/resources/compute-pipeline","title":"ComputePipeline","description":"ComputePipeline is only available on WebGPU. Note that you can still perform","sidebar":"sidebar"},"api-reference/core/resources/external-texture":{"id":"api-reference/core/resources/external-texture","title":"ExternalTexture","description":"WebGPU only."},"api-reference/core/resources/framebuffer":{"id":"api-reference/core/resources/framebuffer","title":"Framebuffer","description":"A Framebuffer holds textures that will be used as render targets for RenderPipelines","sidebar":"sidebar"},"api-reference/core/resources/render-pass":{"id":"api-reference/core/resources/render-pass","title":"RenderPass","description":"Usage"},"api-reference/core/resources/render-pipeline":{"id":"api-reference/core/resources/render-pipeline","title":"RenderPipeline","description":"A RenderPipeline contains a matched pair of vertex and fragment shaders that can be exectued on the GPU by calling RenderPipeline.draw(). handle compilation and linking of shaders, and store uniform values. They provide draw call which allows the application to run the shaders on specified input data.","sidebar":"sidebar"},"api-reference/core/resources/sampler":{"id":"api-reference/core/resources/sampler","title":"Sampler","description":"A Sampler is an immutable object that holds a set of sampling parameters for texture access.","sidebar":"sidebar"},"api-reference/core/resources/shader":{"id":"api-reference/core/resources/shader","title":"Shader","description":"The Shader class holds a compiled shader.","sidebar":"sidebar"},"api-reference/core/resources/texture":{"id":"api-reference/core/resources/texture","title":"Texture","description":"A Texture is a WebGL object that contains one or more images that all have the same image format. Shaders can read from textures (through a sampler uniform) and they can be set up as render targets (by attaching them to a framebuffer).","sidebar":"sidebar"},"api-reference/core/resources/transform-feedback":{"id":"api-reference/core/resources/transform-feedback","title":"TransformFeedback","description":"NOTICE: TransformFeedback is only available in WebGL 2."},"api-reference/core/resources/vertex-array":{"id":"api-reference/core/resources/vertex-array","title":"VertexArray","description":"A VertexArray stores a set of vertex attribute bindings, including the index buffer.","sidebar":"sidebar"},"api-reference/core/shader-layout":{"id":"api-reference/core/shader-layout","title":"ShaderLayout","description":"A ShaderLayout object describes the static structure a `RenderPipeline, \\"location\\" and structure of binding points of shaders,","sidebar":"sidebar"},"api-reference/core/shader-logs":{"id":"api-reference/core/shader-logs","title":"Shader Logs","description":"Shader compilation and linking logs contain important information about .","sidebar":"sidebar"},"api-reference/core/texture-formats":{"id":"api-reference/core/texture-formats","title":"Texture Formats","description":"The term \\"texture format\\" here refers to how pixels are stored in memory, which is an important property of a GPU Texture","sidebar":"sidebar"},"api-reference/core/uniform-buffer-layout":{"id":"api-reference/core/uniform-buffer-layout","title":"UniformBufferLayout","description":"This page describes deprecated components in the legacy luma.gl v8 API."},"api-reference/core/uniform-store":{"id":"api-reference/core/uniform-store","title":"UniformStore","description":"A uniform store holds uniform values for a set of different uniform buffers,"},"api-reference/engine/animation-loop":{"id":"api-reference/engine/animation-loop","title":"AnimationLoop","description":"Manages an animation loop and optionally a WebGL context and a WebGL canvas. It provides a number of features related to initialization and animation of a WebGL context.","sidebar":"sidebar"},"api-reference/engine/animation-loop-template":{"id":"api-reference/engine/animation-loop-template","title":"AnimationLoopTemplate","description":"AnimationLoopTemplate is a helper class that creates and manages the application\'s render loop.","sidebar":"sidebar"},"api-reference/engine/animation/key-frames":{"id":"api-reference/engine/animation/key-frames","title":"KeyFrames","description":"Manages key frame animation data. Associates time points with arbitrary data and provides methods to access key times and data, and an interpolation factor, based on the current time.","sidebar":"sidebar"},"api-reference/engine/animation/timeline":{"id":"api-reference/engine/animation/timeline","title":"Timeline","description":"Manages an animation timeline, with multiple channels that can be running at different rates, durations, etc. Many methods (play, pause) assume that the update method is being called once per frame with a \\"global time\\". This automatically done for AnimationLoop.timeline object.","sidebar":"sidebar"},"api-reference/engine/geometry/geometries":{"id":"api-reference/engine/geometry/geometries","title":"Built-in Geometries","description":"@luma.gl/engine provides several built in geometry primitives (subclasses of Geometry). The generated geometry instances will have indices and POSITION, NORMAL and TEXCOORD_0 attributes.","sidebar":"sidebar"},"api-reference/engine/geometry/geometry":{"id":"api-reference/engine/geometry/geometry","title":"Geometry","description":"The Geometry class holds a collection of vertex array attributes representing a geometric primitive.","sidebar":"sidebar"},"api-reference/engine/gpgpu/gpu-point-in-polygon":{"id":"api-reference/engine/gpgpu/gpu-point-in-polygon","title":"GPUPointInPolygon","description":"GPUPointInPolygon provides GPU accelerated PIP (Point-In-Polygon) testing functionality. A given set of 2D points and one or more 2D polygons, it computes, whether each point is inside or outside of any polygon.","sidebar":"sidebar"},"api-reference/engine/gpgpu/histopyramid":{"id":"api-reference/engine/gpgpu/histopyramid","title":"Histopyramid","description":"histopyramid is only available in WebGL 2.","sidebar":"sidebar"},"api-reference/engine/model":{"id":"api-reference/engine/model","title":"Model","description":"The Model class is the centerpiece of the luma.gl API. It brings together all the different functionality needed to run shaders and perform draw calls in a single, easy-to-use interface.","sidebar":"sidebar"},"api-reference/engine/pipeline-factory":{"id":"api-reference/engine/pipeline-factory","title":"PipelineFactory","description":"The PipelineFactory class provides a createRenderPipeline() method that caches and reuses render pipelines.","sidebar":"sidebar"},"api-reference/engine/README":{"id":"api-reference/engine/README","title":"Overview","description":"The @luma.gl/engine module contains a set of basic 3D framework classes intended"},"api-reference/engine/scenegraph/group-node":{"id":"api-reference/engine/scenegraph/group-node","title":"GroupNode","description":"A GroupNode is a subclass of ScenegraphNode that holds a list of ScenegraphNode children. Since . A GroupNode can be a child of another GroupNode and thus be used to create hierarchical scene graphs.","sidebar":"sidebar"},"api-reference/engine/scenegraph/model-node":{"id":"api-reference/engine/scenegraph/model-node","title":"ModelNode","description":"ModelNode is simply a ScenegraphNode that contains a Model for drawing.","sidebar":"sidebar"},"api-reference/engine/scenegraph/scenegraph-node":{"id":"api-reference/engine/scenegraph/scenegraph-node","title":"ScenegraphNode","description":"The ScenegraphNode is a base class for objects in the luma.gl scene graph, such as Model, Group and Camera. It holds the transformation matrix (i.e. the position, orientation and scale) of the object.","sidebar":"sidebar"},"api-reference/engine/transform":{"id":"api-reference/engine/transform","title":"Transform","description":"The Transform class provides easy interface to perform Transform Feedback operations on given data. Applications can use this class to move data processing from CPU to GPU, where multiple parallel execution units will be used for processing. Data is handled in form of Buffer objects, i.e. data resides in the GPU memory. Output of this class can directly set as attributes on Model or VertexArray for regular rendering operations, CPU access is not required hence avoids expensive CPU and GPU sync.","sidebar":"sidebar"},"api-reference/engine/transform/buffer-transform":{"id":"api-reference/engine/transform/buffer-transform","title":"BufferTransform","description":"BufferTransform is an internal helper class for Transform, responsible for managing resources and state required for reading from and/or writing to Buffer objects. It auto creates feedbackBufferes when requested, creates TransformFeedback objects. Maintains all buffer bindings, when swapping is eanbled, two binding objects are created for easy switching of all WebGL resource binginds.","sidebar":"sidebar"},"api-reference/engine/transform/texture-transform":{"id":"api-reference/engine/transform/texture-transform","title":"TextureTransform","description":"TextureTransform is an internal helper class for Transform, responsible for managing resources and state required for reading from and/or writing to Texture objects. It auto creates Texture objects when requested, creates Framebuffer objects. Maintains all texture bindings, when swapping is eanbled, two binding objects are created for easy switching of all WebGL resource binginds.","sidebar":"sidebar"},"api-reference/gltf/README":{"id":"api-reference/gltf/README","title":"gltf","description":"Classes and functions in @luma.gl/gltf","sidebar":"sidebar"},"api-reference/README":{"id":"api-reference/README","title":"Overview","description":"luma.gl is packaged and published as a suite of composable npm modules, so that applications can choose what functionality they need.","sidebar":"sidebar"},"api-reference/shadertools/README":{"id":"api-reference/shadertools/README","title":"Overview","description":"@luma.gl/shadertools provides:","sidebar":"sidebar"},"api-reference/shadertools/shader-assembler":{"id":"api-reference/shadertools/shader-assembler","title":"ShaderAssembler","description":"The functionality of the shadertools module shader system is primarily exposed","sidebar":"sidebar"},"api-reference/shadertools/shader-info":{"id":"api-reference/shadertools/shader-info","title":"Shader Parsing","description":"It is sometimes useful to be able to inspect shader source code","sidebar":"sidebar"},"api-reference/shadertools/shader-modules":{"id":"api-reference/shadertools/shader-modules","title":"Shader Modules","description":"Uniform Blocks","sidebar":"sidebar"},"api-reference/shadertools/shader-modules/fp32":{"id":"api-reference/shadertools/shader-modules/fp32","title":"fp32 (32-bit Floating Point)","description":"Provides \\"improved\\" 32-bit math support to GPU shaders on certain platforms,","sidebar":"sidebar"},"api-reference/shadertools/shader-modules/fp64":{"id":"api-reference/shadertools/shader-modules/fp64","title":"fp64 (64-bit Floating Point)","description":"Provides basic 64-bit math support in GPU shaders:","sidebar":"sidebar"},"api-reference/shadertools/shader-modules/gouraud-material":{"id":"api-reference/shadertools/shader-modules/gouraud-material","title":"gouraudMaterial","description":"The goraudMaterial shader module provides functions to apply gouraud shading (per vertex) to your geometry.","sidebar":"sidebar"},"api-reference/shadertools/shader-modules/lights":{"id":"api-reference/shadertools/shader-modules/lights","title":"lights","description":"The lights` shader module collects uniforms describing the lights in a scene."},"api-reference/shadertools/shader-modules/pbr-material":{"id":"api-reference/shadertools/shader-modules/pbr-material","title":"pbrMaterial","description":"Implements Physically Based Shading of a microfacet surface defined by a glTF material.","sidebar":"sidebar"},"api-reference/shadertools/shader-modules/phong-material":{"id":"api-reference/shadertools/shader-modules/phong-material","title":"phongMaterial","description":"This phongMaterial shader module provides functions to apply phong shading (per fragment) to your geometry.","sidebar":"sidebar"},"api-reference/shadertools/shader-modules/picking":{"id":"api-reference/shadertools/shader-modules/picking","title":"picking","description":"Provides support for color-based picking.","sidebar":"sidebar"},"api-reference/shadertools/shader-modules/project":{"id":"api-reference/shadertools/shader-modules/project","title":"project","description":"A basic projection module.","sidebar":"sidebar"},"api-reference/shadertools/shader-passes/image-processing":{"id":"api-reference/shadertools/shader-passes/image-processing","title":"Image Processing","description":"Screen space effects packaged as reusable shader modules in @luma.gl/shadertools based on the glfx library.","sidebar":"sidebar"},"api-reference/test-utils/README":{"id":"api-reference/test-utils/README","title":"Overview","description":"@luma.gl/test-utils contains support for testing luma.gl programs.","sidebar":"sidebar"},"api-reference/test-utils/snapshot-test-runner":{"id":"api-reference/test-utils/snapshot-test-runner","title":"SnapshotTestRunner","description":"Client-side utility for browser-based WebGL render tests.","sidebar":"sidebar"},"api-reference/webgl/README":{"id":"api-reference/webgl/README","title":"@luma.gl/webgl","description":"WebGL Device Adapter","sidebar":"sidebar"},"api-reference/webgpu/README":{"id":"api-reference/webgpu/README","title":"Overview","description":"WebGPU Device Adapter","sidebar":"sidebar"},"developer-guide/bundling":{"id":"developer-guide/bundling","title":"Bundling","description":"Optimizing for Bundle Size","sidebar":"sidebar"},"developer-guide/contributing":{"id":"developer-guide/contributing","title":"Contributing","description":"luma.gl welcomes contributions from the community. Smaller fixes","sidebar":"sidebar"},"developer-guide/debugging":{"id":"developer-guide/debugging","title":"Debugging","description":"Debugging GPU code can be challenging. Standard CPU-side debugging tools like","sidebar":"sidebar"},"developer-guide/editing":{"id":"developer-guide/editing","title":"Editing","description":"Shader Syntax Highlighting"},"developer-guide/installing":{"id":"developer-guide/installing","title":"Installing","description":"luma.gl is published as a suite of npm modules. Each module responsible for a particular part of the rendering stack.","sidebar":"sidebar"},"developer-guide/profiling":{"id":"developer-guide/profiling","title":"Profiling","description":"GPU programming is all about performance, so having tools to systematically","sidebar":"sidebar"},"developer-guide/README":{"id":"developer-guide/README","title":"Developer Guide","description":"This developer guide focuses on the practicalities of developing with the luma.gl API,","sidebar":"sidebar"},"developer-guide/testing":{"id":"developer-guide/testing","title":"Testing","description":"Testing webgl programs can be tricky...","sidebar":"sidebar"},"faq":{"id":"faq","title":"FAQ","description":"How do I draw to the screen in luma.gl?"},"getting-started":{"id":"getting-started","title":"Getting Started","description":""},"README":{"id":"README","title":"Overview","description":"luma.gl is a modern GPU toolkit for the Web, focused on processing and visualization of big data.","sidebar":"sidebar"},"tutorials/external-context":{"id":"tutorials/external-context","title":"External WebGL Contexts","description":"This page applies to WebGL only","sidebar":"sidebar"},"tutorials/hello-cube":{"id":"tutorials/hello-cube","title":"Hello Cube","description":"In this tutorial, we\'ll pull together several of the techniques we\'ve looked at","sidebar":"sidebar"},"tutorials/hello-instancing":{"id":"tutorials/hello-instancing","title":"Hello Instancing","description":"In this tutorial, we\'ll work through how to do instanced drawing with luma.gl\'s high-level APIs. We\'ll also take this opportunity to introduce luma.gl shader modules. We\'ll begin with our hello triangle app and make some modifications. First let\'s create a shader module:","sidebar":"sidebar"},"tutorials/hello-triangle":{"id":"tutorials/hello-triangle","title":"Hello Triangle","description":"This tutorial will demonstrate how to draw a triangle using luma.gl\'s high-level APIs.","sidebar":"sidebar"},"tutorials/instanced-transform":{"id":"tutorials/instanced-transform","title":"Instanced Transform","description":"TransformFeedback based examples are temporarily disabled until Transform class is ported to luma.gl v9","sidebar":"sidebar"},"tutorials/lighting":{"id":"tutorials/lighting","title":"Lighting","description":"This tutorial will expand on the previous one, but we\'ll add some lighting to enhance the feeling of 3D in the scene. To accomplish this, we\'ll use one of luma.gl\'s built-in shader modules for the first time.","sidebar":"sidebar"},"tutorials/README":{"id":"tutorials/README","title":"Setup","description":"This tutorial will walk you through setting up a basic development project for luma.gl applications using Vite tooling. Later tutorials will build on this one, so we recommend going through it first.","sidebar":"sidebar"},"tutorials/shader-hooks":{"id":"tutorials/shader-hooks","title":"Shader Hooks","description":"In the previous tutorial, we used shader modules","sidebar":"sidebar"},"tutorials/shader-modules":{"id":"tutorials/shader-modules","title":"Shader Modules","description":"This tutorial will demonstrate how to use luma.gl shader modules to make","sidebar":"sidebar"},"tutorials/transform":{"id":"tutorials/transform","title":"Transform","description":"TransformFeedback based examples are temporarily disabled until Transform class is ported to luma.gl v9","sidebar":"sidebar"},"tutorials/transform-feedback":{"id":"tutorials/transform-feedback","title":"Transform Feedback","description":"TransformFeedback based examples are temporarily disabled until Transform class is ported to luma.gl v9","sidebar":"sidebar"},"tutorials/whats-next":{"id":"tutorials/whats-next","title":"What\'s Next?","description":"That concludes our luma.gl tutorial series. If you went through the full set of tutorials, you\'ve taken a deep dive into some of luma.gl\'s more powerful features, including polyfilling the WebGL context, shader modules and composition, instanced drawing, and transform feedback. To dig deeper into luma.gl\'s API, we recommend playing around with the examples in the examples directory of the repository, which demonstrate various parts of the API in more detail. They can also be browsed on the website.","sidebar":"sidebar"},"upgrade-guide/legacy-guide":{"id":"upgrade-guide/legacy-guide","title":"Legacy Upgrade Guide","description":"This page contains upgrade guides for older luma.gl releases (up through v8.5). For upgrading to luma.gl v9, refer to the main Upgrade Guide.","sidebar":"sidebar"},"upgrade-guide/porting-guide":{"id":"upgrade-guide/porting-guide","title":"Porting Guide","description":"Given that the changes in the v9 API are quite extensive, this separate porting guide is provided to hopefully help plan the upgrade process.","sidebar":"sidebar"},"upgrade-guide/README":{"id":"upgrade-guide/README","title":"Upgrade Guide","description":"This upgrade guide lists breaking changes in the luma.gl API, and provides information on how to update applications.","sidebar":"sidebar"},"whats-new":{"id":"whats-new","title":"What\'s New","description":"Version 9.0 (In Development)","sidebar":"sidebar"}}}')}}]);