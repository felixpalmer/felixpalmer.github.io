"use strict";(self.webpackChunkproject_website=self.webpackChunkproject_website||[]).push([[5856],{35983:(t,i,n)=>{function o(t){let i=1/0,n=1/0,o=1/0,e=-1/0,r=-1/0,a=-1/0;const l=t.POSITION?t.POSITION.value:[],s=l&&l.length;for(let c=0;c<s;c+=3){const t=l[c],s=l[c+1],h=l[c+2];i=t<i?t:i,n=s<n?s:n,o=h<o?h:o,e=t>e?t:e,r=s>r?s:r,a=h>a?h:a}return[[i,n,o],[e,r,a]]}n.d(i,{l:()=>o})},35521:(t,i,n)=>{n.d(i,{G:()=>r});var o=n(25337),e=n(4500);class r extends o.V{constructor(t={}){const{id:i=(0,e.L)("sphere-geometry")}=t,{indices:n,attributes:o}=function(t){const{nlat:i=10,nlong:n=10}=t,o=0,e=Math.PI-o,r=0,a=2*Math.PI-r,l=(i+1)*(n+1),s=(i,n,o,e,r)=>t.radius||1,c=new Float32Array(3*l),h=new Float32Array(3*l),g=new Float32Array(2*l),f=new(l>65535?Uint32Array:Uint16Array)(i*n*6);for(let d=0;d<=i;d++)for(let t=0;t<=n;t++){const o=t/n,r=d/i,l=t+d*(n+1),f=2*l,u=3*l,p=a*o,_=e*r,m=Math.sin(p),v=Math.cos(p),w=Math.sin(_),M=v*w,C=Math.cos(_),L=m*w,b=s(M,C,L,o,r);c[u+0]=b*M,c[u+1]=b*C,c[u+2]=b*L,h[u+0]=M,h[u+1]=C,h[u+2]=L,g[f+0]=o,g[f+1]=1-r}const u=n+1;for(let d=0;d<n;d++)for(let t=0;t<i;t++){const n=6*(d*i+t);f[n+0]=t*u+d,f[n+1]=t*u+d+1,f[n+2]=(t+1)*u+d,f[n+3]=(t+1)*u+d,f[n+4]=t*u+d+1,f[n+5]=(t+1)*u+d+1}return{indices:{size:1,value:f},attributes:{POSITION:{size:3,value:c},NORMAL:{size:3,value:h},TEXCOORD_0:{size:2,value:g}}}}(t);super({...t,id:i,topology:"triangle-list",indices:n,attributes:{...o,...t.attributes}})}}},72404:(t,i,n)=>{n.d(i,{w:()=>r});var o=n(10513);var e=n(38846);const r={name:"phongMaterial",dependencies:[o.x],source:"struct phongMaterialUniforms {\n  ambient: f32,\n  diffuse: f32,\n  shininess: f32,\n  specularColor: vec3<f32>,\n};\n\n@binding(2) @group(0) var<uniform> material : phongMaterialUniforms;\n\nfn lighting_getLightColor(surfaceColor: vec3<f32>, light_direction: vec3<f32>, view_direction: vec3<f32>, normal_worldspace: vec3<f32>, color: vec3<f32>) -> vec3<f32> {\n  let halfway_direction: vec3<f32> = normalize(light_direction + view_direction);\n  var lambertian: f32 = dot(light_direction, normal_worldspace);\n  var specular: f32 = 0.0;\n  if (lambertian > 0.0) {\n    let specular_angle = max(dot(normal_worldspace, halfway_direction), 0.0);\n    specular = pow(specular_angle, material.shininess);\n  }\n  lambertian = max(lambertian, 0.0);\n  return (lambertian * material.diffuse * surfaceColor + specular * material.specularColor) * color;\n}\n\nfn lighting_getLightColor2(surfaceColor: vec3<f32>, cameraPosition: vec3<f32>, position_worldspace: vec3<f32>, normal_worldspace: vec3<f32>) -> vec3<f32> {\n  var lightColor: vec3<f32> = surfaceColor;\n\n  if (lighting.enabled == 0) {\n    return lightColor;\n  }\n\n  let view_direction: vec3<f32> = normalize(cameraPosition - position_worldspace);\n  lightColor = material.ambient * surfaceColor * lighting.ambientColor;\n\n  if (lighting.lightType == 0) {\n    let pointLight: PointLight  = lighting_getPointLight(0);\n    let light_position_worldspace: vec3<f32> = pointLight.position;\n    let light_direction: vec3<f32> = normalize(light_position_worldspace - position_worldspace);\n    lightColor += lighting_getLightColor(surfaceColor, light_direction, view_direction, normal_worldspace, pointLight.color);\n  } else if (lighting.lightType == 1) {\n    var directionalLight: DirectionalLight = lighting_getDirectionalLight(0);\n    lightColor += lighting_getLightColor(surfaceColor, -directionalLight.direction, view_direction, normal_worldspace, directionalLight.color);\n  }\n  \n  return lightColor;\n  /*\n  for (int i = 0; i < MAX_LIGHTS; i++) {\n    if (i >= lighting.pointLightCount) {\n      break;\n    }\n    PointLight pointLight = lighting.pointLight[i];\n    vec3 light_position_worldspace = pointLight.position;\n    vec3 light_direction = normalize(light_position_worldspace - position_worldspace);\n    lightColor += lighting_getLightColor(surfaceColor, light_direction, view_direction, normal_worldspace, pointLight.color);\n  }\n\n  for (int i = 0; i < MAX_LIGHTS; i++) {\n    if (i >= lighting.directionalLightCount) {\n      break;\n    }\n    DirectionalLight directionalLight = lighting.directionalLight[i];\n    lightColor += lighting_getLightColor(surfaceColor, -directionalLight.direction, view_direction, normal_worldspace, directionalLight.color);\n  }\n  */\n}\n\nfn lighting_getSpecularLightColor(cameraPosition: vec3<f32>, position_worldspace: vec3<f32>, normal_worldspace: vec3<f32>) -> vec3<f32>{\n  var lightColor = vec3<f32>(0, 0, 0);\n  let surfaceColor = vec3<f32>(0, 0, 0);\n\n  if (lighting.enabled == 0) {\n    let view_direction = normalize(cameraPosition - position_worldspace);\n\n    switch (lighting.lightType) {\n      case 0, default: {\n        let pointLight: PointLight = lighting_getPointLight(0);\n        let light_position_worldspace: vec3<f32> = pointLight.position;\n        let light_direction: vec3<f32> = normalize(light_position_worldspace - position_worldspace);\n        lightColor += lighting_getLightColor(surfaceColor, light_direction, view_direction, normal_worldspace, pointLight.color);\n      }\n      case 1: {\n        let directionalLight: DirectionalLight = lighting_getDirectionalLight(0);\n        lightColor += lighting_getLightColor(surfaceColor, -directionalLight.direction, view_direction, normal_worldspace, directionalLight.color);\n      }\n    }\n  }\n  return lightColor;\n}\n",vs:e.X,fs:e.l,defines:{LIGHTING_FRAGMENT:1},uniformTypes:{ambient:"f32",diffuse:"f32",shininess:"f32",specularColor:"vec3<f32>"},defaultUniforms:{ambient:.35,diffuse:.6,shininess:32,specularColor:[.15,.15,.15]},getUniforms(t){const i={...t};return i.specularColor&&(i.specularColor=i.specularColor.map((t=>t/255))),{...r.defaultUniforms,...i}}}},58296:(t,i,n)=>{n.d(i,{_:()=>u});const o=Math.PI/180,e=864e5,r=2440588,a=2451545,l=23.4397*o,s=357.5291,c=.98560028,h=280.147,g=360.9856235;function f(t,i,n){const l=o*-n,f=o*i,u=function(t){return function(t){const i="number"==typeof t?t:t.getTime();return i/e-.5+r}(t)-a}(t),v=function(t){const i=function(t){const i=t,n=o*(1.9148*Math.sin(i)+.02*Math.sin(2*i)+3e-4*Math.sin(3*i));return i+n+102.9372*o+Math.PI}((n=t,o*(s+c*n)));var n;return{declination:p(i,0),rightAscension:d(i,0)}}(u),w=function(t,i){return o*(h+g*t)-i}(u,l)-v.rightAscension;return{azimuth:_(w,f,v.declination),altitude:m(w,f,v.declination)}}function u(t,i,n){const{azimuth:o,altitude:e}=f(t,i,n);return[Math.sin(o)*Math.cos(e),Math.cos(o)*Math.cos(e),-Math.sin(e)]}function d(t,i){const n=t;return Math.atan2(Math.sin(n)*Math.cos(l)-Math.tan(i)*Math.sin(l),Math.cos(n))}function p(t,i){const n=t;return Math.asin(Math.sin(i)*Math.cos(l)+Math.cos(i)*Math.sin(l)*Math.sin(n))}function _(t,i,n){const o=t,e=i,r=n;return Math.atan2(Math.sin(o),Math.cos(o)*Math.sin(e)-Math.tan(r)*Math.cos(e))}function m(t,i,n){const o=t,e=i,r=n;return Math.asin(Math.sin(e)*Math.sin(r)+Math.cos(e)*Math.cos(r)*Math.cos(o))}},75228:(t,i,n)=>{n.d(i,{A:()=>e});const o=1e20;class e{constructor({fontSize:t=24,buffer:i=3,radius:n=8,cutoff:o=.25,fontFamily:e="sans-serif",fontWeight:r="normal",fontStyle:a="normal"}={}){this.buffer=i,this.cutoff=o,this.radius=n;const l=this.size=t+4*i,s=this._createCanvas(l),c=this.ctx=s.getContext("2d",{willReadFrequently:!0});c.font=`${a} ${r} ${t}px ${e}`,c.textBaseline="alphabetic",c.textAlign="left",c.fillStyle="black",this.gridOuter=new Float64Array(l*l),this.gridInner=new Float64Array(l*l),this.f=new Float64Array(l),this.z=new Float64Array(l+1),this.v=new Uint16Array(l)}_createCanvas(t){const i=document.createElement("canvas");return i.width=i.height=t,i}draw(t){const{width:i,actualBoundingBoxAscent:n,actualBoundingBoxDescent:e,actualBoundingBoxLeft:a,actualBoundingBoxRight:l}=this.ctx.measureText(t),s=Math.ceil(n),c=Math.max(0,Math.min(this.size-this.buffer,Math.ceil(l-a))),h=Math.min(this.size-this.buffer,s+Math.ceil(e)),g=c+2*this.buffer,f=h+2*this.buffer,u=Math.max(g*f,0),d=new Uint8ClampedArray(u),p={data:d,width:g,height:f,glyphWidth:c,glyphHeight:h,glyphTop:s,glyphLeft:0,glyphAdvance:i};if(0===c||0===h)return p;const{ctx:_,buffer:m,gridInner:v,gridOuter:w}=this;_.clearRect(m,m,c,h),_.fillText(t,m,m+s);const M=_.getImageData(m,m,c,h);w.fill(o,0,u),v.fill(0,0,u);for(let r=0;r<h;r++)for(let t=0;t<c;t++){const i=M.data[4*(r*c+t)+3]/255;if(0===i)continue;const n=(r+m)*g+t+m;if(1===i)w[n]=0,v[n]=o;else{const t=.5-i;w[n]=t>0?t*t:0,v[n]=t<0?t*t:0}}r(w,0,0,g,f,g,this.f,this.v,this.z),r(v,m,m,c,h,g,this.f,this.v,this.z);for(let o=0;o<u;o++){const t=Math.sqrt(w[o])-Math.sqrt(v[o]);d[o]=Math.round(255-255*(t/this.radius+this.cutoff))}return p}}function r(t,i,n,o,e,r,l,s,c){for(let h=i;h<i+o;h++)a(t,n*r+h,r,e,l,s,c);for(let h=n;h<n+e;h++)a(t,h*r+i,1,o,l,s,c)}function a(t,i,n,e,r,a,l){a[0]=0,l[0]=-o,l[1]=o,r[0]=t[i];for(let s=1,c=0,h=0;s<e;s++){r[s]=t[i+s*n];const e=s*s;do{const t=a[c];h=(r[s]-r[t]+e-t*t)/(s-t)/2}while(h<=l[c]&&--c>-1);c++,a[c]=s,l[c]=h,l[c+1]=o}for(let o=0,s=0;o<e;o++){for(;l[s+1]<o;)s++;const e=a[s],c=o-e;t[i+o*n]=r[e]+c*c}}}}]);