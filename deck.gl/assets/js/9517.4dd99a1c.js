"use strict";(self.webpackChunkproject_website=self.webpackChunkproject_website||[]).push([[9517],{25337:(t,i,e)=>{e.d(i,{V:()=>n});var o=e(4500);class n{id;topology;vertexCount;indices;attributes;userData={};constructor(t){const{attributes:i={},indices:e=null,vertexCount:n=null}=t;this.id=t.id||(0,o.L)("geometry"),this.topology=t.topology,e&&(this.indices=ArrayBuffer.isView(e)?{value:e,size:1}:e),this.attributes={};for(const[o,r]of Object.entries(i)){const t=ArrayBuffer.isView(r)?{value:r}:r;if(!ArrayBuffer.isView(t.value))throw new Error(`${this._print(o)}: must be typed array or object with value as typed array`);if("POSITION"!==o&&"positions"!==o||t.size||(t.size=3),"indices"===o){if(this.indices)throw new Error("Multiple indices detected");this.indices=t}else this.attributes[o]=t}this.indices&&void 0!==this.indices.isIndexed&&(this.indices=Object.assign({},this.indices),delete this.indices.isIndexed),this.vertexCount=n||this._calculateVertexCount(this.attributes,this.indices)}getVertexCount(){return this.vertexCount}getAttributes(){return this.indices?{indices:this.indices,...this.attributes}:this.attributes}_print(t){return`Geometry ${this.id} attribute ${t}`}_setAttributes(t,i){return this}_calculateVertexCount(t,i){if(i)return i.value.length;let e=1/0;for(const o of Object.values(t)){const{value:t,size:i,constant:n}=o;!n&&t&&void 0!==i&&i>=1&&(e=Math.min(e,t.length/i))}return e}}},49042:(t,i,e)=>{e.d(i,{q:()=>o});const o={props:{},uniforms:{},name:"picking",uniformTypes:{isActive:"f32",isAttribute:"f32",isHighlightActive:"f32",useFloatColors:"f32",highlightedObjectColor:"vec3<f32>",highlightColor:"vec4<f32>"},defaultUniforms:{isActive:!1,isAttribute:!1,isHighlightActive:!1,useFloatColors:!0,highlightedObjectColor:[0,0,0],highlightColor:[0,1,1,1]},vs:"uniform pickingUniforms {\n  float isActive;\n  float isAttribute;\n  float isHighlightActive;\n  float useFloatColors;\n  vec3 highlightedObjectColor;\n  vec4 highlightColor;\n} picking;\n\nout vec4 picking_vRGBcolor_Avalid;\n\n// Normalize unsigned byte color to 0-1 range\nvec3 picking_normalizeColor(vec3 color) {\n  return picking.useFloatColors > 0.5 ? color : color / 255.0;\n}\n\n// Normalize unsigned byte color to 0-1 range\nvec4 picking_normalizeColor(vec4 color) {\n  return picking.useFloatColors > 0.5 ? color : color / 255.0;\n}\n\nbool picking_isColorZero(vec3 color) {\n  return dot(color, vec3(1.0)) < 0.00001;\n}\n\nbool picking_isColorValid(vec3 color) {\n  return dot(color, vec3(1.0)) > 0.00001;\n}\n\n// Check if this vertex is highlighted \nbool isVertexHighlighted(vec3 vertexColor) {\n  vec3 highlightedObjectColor = picking_normalizeColor(picking.highlightedObjectColor);\n  return\n    bool(picking.isHighlightActive) && picking_isColorZero(abs(vertexColor - highlightedObjectColor));\n}\n\n// Set the current picking color\nvoid picking_setPickingColor(vec3 pickingColor) {\n  pickingColor = picking_normalizeColor(pickingColor);\n\n  if (bool(picking.isActive)) {\n    // Use alpha as the validity flag. If pickingColor is [0, 0, 0] fragment is non-pickable\n    picking_vRGBcolor_Avalid.a = float(picking_isColorValid(pickingColor));\n\n    if (!bool(picking.isAttribute)) {\n      // Stores the picking color so that the fragment shader can render it during picking\n      picking_vRGBcolor_Avalid.rgb = pickingColor;\n    }\n  } else {\n    // Do the comparison with selected item color in vertex shader as it should mean fewer compares\n    picking_vRGBcolor_Avalid.a = float(isVertexHighlighted(pickingColor));\n  }\n}\n\nvoid picking_setPickingAttribute(float value) {\n  if (bool(picking.isAttribute)) {\n    picking_vRGBcolor_Avalid.r = value;\n  }\n}\n\nvoid picking_setPickingAttribute(vec2 value) {\n  if (bool(picking.isAttribute)) {\n    picking_vRGBcolor_Avalid.rg = value;\n  }\n}\n\nvoid picking_setPickingAttribute(vec3 value) {\n  if (bool(picking.isAttribute)) {\n    picking_vRGBcolor_Avalid.rgb = value;\n  }\n}\n",fs:"uniform pickingUniforms {\n  float isActive;\n  float isAttribute;\n  float isHighlightActive;\n  float useFloatColors;\n  vec3 highlightedObjectColor;\n  vec4 highlightColor;\n} picking;\n\nin vec4 picking_vRGBcolor_Avalid;\n\n/*\n * Returns highlight color if this item is selected.\n */\nvec4 picking_filterHighlightColor(vec4 color) {\n  // If we are still picking, we don't highlight\n  if (picking.isActive > 0.5) {\n    return color;\n  }\n\n  bool selected = bool(picking_vRGBcolor_Avalid.a);\n\n  if (selected) {\n    // Blend in highlight color based on its alpha value\n    float highLightAlpha = picking.highlightColor.a;\n    float blendedAlpha = highLightAlpha + color.a * (1.0 - highLightAlpha);\n    float highLightRatio = highLightAlpha / blendedAlpha;\n\n    vec3 blendedRGB = mix(color.rgb, picking.highlightColor.rgb, highLightRatio);\n    return vec4(blendedRGB, blendedAlpha);\n  } else {\n    return color;\n  }\n}\n\n/*\n * Returns picking color if picking enabled else unmodified argument.\n */\nvec4 picking_filterPickingColor(vec4 color) {\n  if (bool(picking.isActive)) {\n    if (picking_vRGBcolor_Avalid.a == 0.0) {\n      discard;\n    }\n    return picking_vRGBcolor_Avalid;\n  }\n  return color;\n}\n\n/*\n * Returns picking color if picking is enabled if not\n * highlight color if this item is selected, otherwise unmodified argument.\n */\nvec4 picking_filterColor(vec4 color) {\n  vec4 highlightColor = picking_filterHighlightColor(color);\n  return picking_filterPickingColor(highlightColor);\n}\n",getUniforms:function(t={},i){const e={};if(void 0===t.highlightedObjectColor);else if(null===t.highlightedObjectColor)e.isHighlightActive=!1;else{e.isHighlightActive=!0;const i=t.highlightedObjectColor.slice(0,3);e.highlightedObjectColor=i}if(t.highlightColor){const i=Array.from(t.highlightColor,(t=>t/255));Number.isFinite(i[3])||(i[3]=1),e.highlightColor=i}void 0!==t.isActive&&(e.isActive=Boolean(t.isActive),e.isAttribute=Boolean(t.isAttribute));void 0!==t.useFloatColors&&(e.useFloatColors=Boolean(t.useFloatColors));return e}}},28453:(t,i,e)=>{e.d(i,{R:()=>s,x:()=>h});var o=e(96540);const n={},r=o.createContext(n);function s(t){const i=o.useContext(r);return o.useMemo((function(){return"function"==typeof t?t(i):{...i,...t}}),[i,t])}function h(t){let i;return i=t.disableParentContext?"function"==typeof t.components?t.components(n):t.components||n:s(t.components),o.createElement(r.Provider,{value:i},t.children)}},99090:(t,i,e)=>{e.d(i,{A:()=>d});const o=[Int8Array,Uint8Array,Uint8ClampedArray,Int16Array,Uint16Array,Int32Array,Uint32Array,Float32Array,Float64Array];class n{static from(t){if(!(t instanceof ArrayBuffer))throw new Error("Data must be an instance of ArrayBuffer.");const[i,e]=new Uint8Array(t,0,2);if(219!==i)throw new Error("Data does not appear to be in a KDBush format.");const r=e>>4;if(1!==r)throw new Error(`Got v${r} data when expected v1.`);const s=o[15&e];if(!s)throw new Error("Unrecognized array type.");const[h]=new Uint16Array(t,2,1),[c]=new Uint32Array(t,4,1);return new n(c,h,s,t)}constructor(t,i=64,e=Float64Array,n){if(isNaN(t)||t<0)throw new Error(`Unpexpected numItems value: ${t}.`);this.numItems=+t,this.nodeSize=Math.min(Math.max(+i,2),65535),this.ArrayType=e,this.IndexArrayType=t<65536?Uint16Array:Uint32Array;const r=o.indexOf(this.ArrayType),s=2*t*this.ArrayType.BYTES_PER_ELEMENT,h=t*this.IndexArrayType.BYTES_PER_ELEMENT,c=(8-h%8)%8;if(r<0)throw new Error(`Unexpected typed array class: ${e}.`);n&&n instanceof ArrayBuffer?(this.data=n,this.ids=new this.IndexArrayType(this.data,8,t),this.coords=new this.ArrayType(this.data,8+h+c,2*t),this._pos=2*t,this._finished=!0):(this.data=new ArrayBuffer(8+s+h+c),this.ids=new this.IndexArrayType(this.data,8,t),this.coords=new this.ArrayType(this.data,8+h+c,2*t),this._pos=0,this._finished=!1,new Uint8Array(this.data,0,2).set([219,16+r]),new Uint16Array(this.data,2,1)[0]=i,new Uint32Array(this.data,4,1)[0]=t)}add(t,i){const e=this._pos>>1;return this.ids[e]=e,this.coords[this._pos++]=t,this.coords[this._pos++]=i,e}finish(){const t=this._pos>>1;if(t!==this.numItems)throw new Error(`Added ${t} items when expected ${this.numItems}.`);return r(this.ids,this.coords,this.nodeSize,0,this.numItems-1,0),this._finished=!0,this}range(t,i,e,o){if(!this._finished)throw new Error("Data not yet indexed - call index.finish().");const{ids:n,coords:r,nodeSize:s}=this,h=[0,n.length-1,0],c=[];for(;h.length;){const l=h.pop()||0,a=h.pop()||0,u=h.pop()||0;if(a-u<=s){for(let s=u;s<=a;s++){const h=r[2*s],l=r[2*s+1];h>=t&&h<=e&&l>=i&&l<=o&&c.push(n[s])}continue}const g=u+a>>1,d=r[2*g],p=r[2*g+1];d>=t&&d<=e&&p>=i&&p<=o&&c.push(n[g]),(0===l?t<=d:i<=p)&&(h.push(u),h.push(g-1),h.push(1-l)),(0===l?e>=d:o>=p)&&(h.push(g+1),h.push(a),h.push(1-l))}return c}within(t,i,e){if(!this._finished)throw new Error("Data not yet indexed - call index.finish().");const{ids:o,coords:n,nodeSize:r}=this,s=[0,o.length-1,0],h=[],c=e*e;for(;s.length;){const a=s.pop()||0,u=s.pop()||0,g=s.pop()||0;if(u-g<=r){for(let e=g;e<=u;e++)l(n[2*e],n[2*e+1],t,i)<=c&&h.push(o[e]);continue}const d=g+u>>1,p=n[2*d],f=n[2*d+1];l(p,f,t,i)<=c&&h.push(o[d]),(0===a?t-e<=p:i-e<=f)&&(s.push(g),s.push(d-1),s.push(1-a)),(0===a?t+e>=p:i+e>=f)&&(s.push(d+1),s.push(u),s.push(1-a))}return h}}function r(t,i,e,o,n,h){if(n-o<=e)return;const c=o+n>>1;s(t,i,c,o,n,h),r(t,i,e,o,c-1,1-h),r(t,i,e,c+1,n,1-h)}function s(t,i,e,o,n,r){for(;n>o;){if(n-o>600){const h=n-o+1,c=e-o+1,l=Math.log(h),a=.5*Math.exp(2*l/3),u=.5*Math.sqrt(l*a*(h-a)/h)*(c-h/2<0?-1:1);s(t,i,e,Math.max(o,Math.floor(e-c*a/h+u)),Math.min(n,Math.floor(e+(h-c)*a/h+u)),r)}const c=i[2*e+r];let l=o,a=n;for(h(t,i,o,e),i[2*n+r]>c&&h(t,i,o,n);l<a;){for(h(t,i,l,a),l++,a--;i[2*l+r]<c;)l++;for(;i[2*a+r]>c;)a--}i[2*o+r]===c?h(t,i,o,a):(a++,h(t,i,a,n)),a<=e&&(o=a+1),e<=a&&(n=a-1)}}function h(t,i,e,o){c(t,e,o),c(i,2*e,2*o),c(i,2*e+1,2*o+1)}function c(t,i,e){const o=t[i];t[i]=t[e],t[e]=o}function l(t,i,e,o){const n=t-e,r=i-o;return n*n+r*r}const a={minZoom:0,maxZoom:16,minPoints:2,radius:40,extent:512,nodeSize:64,log:!1,generateId:!1,reduce:null,map:t=>t},u=Math.fround||(g=new Float32Array(1),t=>(g[0]=+t,g[0]));var g;class d{constructor(t){this.options=Object.assign(Object.create(a),t),this.trees=new Array(this.options.maxZoom+1),this.stride=this.options.reduce?7:6,this.clusterProps=[]}load(t){const{log:i,minZoom:e,maxZoom:o}=this.options;i&&console.time("total time");const n=`prepare ${t.length} points`;i&&console.time(n),this.points=t;const r=[];for(let h=0;h<t.length;h++){const i=t[h];if(!i.geometry)continue;const[e,o]=i.geometry.coordinates,n=u(v(e)),s=u(m(o));r.push(n,s,1/0,h,-1,1),this.options.reduce&&r.push(0)}let s=this.trees[o+1]=this._createTree(r);i&&console.timeEnd(n);for(let h=o;h>=e;h--){const t=+Date.now();s=this.trees[h]=this._createTree(this._cluster(s,h)),i&&console.log("z%d: %d clusters in %dms",h,s.numItems,+Date.now()-t)}return i&&console.timeEnd("total time"),this}getClusters(t,i){let e=((t[0]+180)%360+360)%360-180;const o=Math.max(-90,Math.min(90,t[1]));let n=180===t[2]?180:((t[2]+180)%360+360)%360-180;const r=Math.max(-90,Math.min(90,t[3]));if(t[2]-t[0]>=360)e=-180,n=180;else if(e>n){const t=this.getClusters([e,o,180,r],i),s=this.getClusters([-180,o,n,r],i);return t.concat(s)}const s=this.trees[this._limitZoom(i)],h=s.range(v(e),m(r),v(n),m(o)),c=s.data,l=[];for(const a of h){const t=this.stride*a;l.push(c[t+5]>1?p(c,t,this.clusterProps):this.points[c[t+3]])}return l}getChildren(t){const i=this._getOriginId(t),e=this._getOriginZoom(t),o="No cluster with the specified id.",n=this.trees[e];if(!n)throw new Error(o);const r=n.data;if(i*this.stride>=r.length)throw new Error(o);const s=this.options.radius/(this.options.extent*Math.pow(2,e-1)),h=r[i*this.stride],c=r[i*this.stride+1],l=n.within(h,c,s),a=[];for(const u of l){const i=u*this.stride;r[i+4]===t&&a.push(r[i+5]>1?p(r,i,this.clusterProps):this.points[r[i+3]])}if(0===a.length)throw new Error(o);return a}getLeaves(t,i,e){i=i||10,e=e||0;const o=[];return this._appendLeaves(o,t,i,e,0),o}getTile(t,i,e){const o=this.trees[this._limitZoom(t)],n=Math.pow(2,t),{extent:r,radius:s}=this.options,h=s/r,c=(e-h)/n,l=(e+1+h)/n,a={features:[]};return this._addTileFeatures(o.range((i-h)/n,c,(i+1+h)/n,l),o.data,i,e,n,a),0===i&&this._addTileFeatures(o.range(1-h/n,c,1,l),o.data,n,e,n,a),i===n-1&&this._addTileFeatures(o.range(0,c,h/n,l),o.data,-1,e,n,a),a.features.length?a:null}getClusterExpansionZoom(t){let i=this._getOriginZoom(t)-1;for(;i<=this.options.maxZoom;){const e=this.getChildren(t);if(i++,1!==e.length)break;t=e[0].properties.cluster_id}return i}_appendLeaves(t,i,e,o,n){const r=this.getChildren(i);for(const s of r){const i=s.properties;if(i&&i.cluster?n+i.point_count<=o?n+=i.point_count:n=this._appendLeaves(t,i.cluster_id,e,o,n):n<o?n++:t.push(s),t.length===e)break}return n}_createTree(t){const i=new n(t.length/this.stride|0,this.options.nodeSize,Float32Array);for(let e=0;e<t.length;e+=this.stride)i.add(t[e],t[e+1]);return i.finish(),i.data=t,i}_addTileFeatures(t,i,e,o,n,r){for(const s of t){const t=s*this.stride,h=i[t+5]>1;let c,l,a;if(h)c=f(i,t,this.clusterProps),l=i[t],a=i[t+1];else{const e=this.points[i[t+3]];c=e.properties;const[o,n]=e.geometry.coordinates;l=v(o),a=m(n)}const u={type:1,geometry:[[Math.round(this.options.extent*(l*n-e)),Math.round(this.options.extent*(a*n-o))]],tags:c};let g;g=h||this.options.generateId?i[t+3]:this.points[i[t+3]].id,void 0!==g&&(u.id=g),r.features.push(u)}}_limitZoom(t){return Math.max(this.options.minZoom,Math.min(Math.floor(+t),this.options.maxZoom+1))}_cluster(t,i){const{radius:e,extent:o,reduce:n,minPoints:r}=this.options,s=e/(o*Math.pow(2,i)),h=t.data,c=[],l=this.stride;for(let a=0;a<h.length;a+=l){if(h[a+2]<=i)continue;h[a+2]=i;const e=h[a],o=h[a+1],u=t.within(h[a],h[a+1],s),g=h[a+5];let d=g;for(const t of u){const e=t*l;h[e+2]>i&&(d+=h[e+5])}if(d>g&&d>=r){let t,r=e*g,s=o*g,p=-1;const f=(a/l<<5)+(i+1)+this.points.length;for(const e of u){const o=e*l;if(h[o+2]<=i)continue;h[o+2]=i;const c=h[o+5];r+=h[o]*c,s+=h[o+1]*c,h[o+4]=f,n&&(t||(t=this._map(h,a,!0),p=this.clusterProps.length,this.clusterProps.push(t)),n(t,this._map(h,o)))}h[a+4]=f,c.push(r/d,s/d,1/0,f,-1,d),n&&c.push(p)}else{for(let t=0;t<l;t++)c.push(h[a+t]);if(d>1)for(const t of u){const e=t*l;if(!(h[e+2]<=i)){h[e+2]=i;for(let t=0;t<l;t++)c.push(h[e+t])}}}}return c}_getOriginId(t){return t-this.points.length>>5}_getOriginZoom(t){return(t-this.points.length)%32}_map(t,i,e){if(t[i+5]>1){const o=this.clusterProps[t[i+6]];return e?Object.assign({},o):o}const o=this.points[t[i+3]].properties,n=this.options.map(o);return e&&n===o?Object.assign({},n):n}}function p(t,i,e){return{type:"Feature",id:t[i+3],properties:f(t,i,e),geometry:{type:"Point",coordinates:[(o=t[i],360*(o-.5)),_(t[i+1])]}};var o}function f(t,i,e){const o=t[i+5],n=o>=1e4?`${Math.round(o/1e3)}k`:o>=1e3?Math.round(o/100)/10+"k":o,r=t[i+6],s=-1===r?{}:Object.assign({},e[r]);return Object.assign(s,{cluster:!0,cluster_id:t[i+3],point_count:o,point_count_abbreviated:n})}function v(t){return t/360+.5}function m(t){const i=Math.sin(t*Math.PI/180),e=.5-.25*Math.log((1+i)/(1-i))/Math.PI;return e<0?0:e>1?1:e}function _(t){const i=(180-360*t)*Math.PI/180;return 360*Math.atan(Math.exp(i))/Math.PI-90}}}]);