"use strict";(self.webpackChunkproject_website=self.webpackChunkproject_website||[]).push([[7093],{3905:(t,i,e)=>{e.d(i,{Zo:()=>h,kt:()=>d});var n=e(67294);function o(t,i,e){return i in t?Object.defineProperty(t,i,{value:e,enumerable:!0,configurable:!0,writable:!0}):t[i]=e,t}function r(t,i){var e=Object.keys(t);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(t);i&&(n=n.filter((function(i){return Object.getOwnPropertyDescriptor(t,i).enumerable}))),e.push.apply(e,n)}return e}function s(t){for(var i=1;i<arguments.length;i++){var e=null!=arguments[i]?arguments[i]:{};i%2?r(Object(e),!0).forEach((function(i){o(t,i,e[i])})):Object.getOwnPropertyDescriptors?Object.defineProperties(t,Object.getOwnPropertyDescriptors(e)):r(Object(e)).forEach((function(i){Object.defineProperty(t,i,Object.getOwnPropertyDescriptor(e,i))}))}return t}function l(t,i){if(null==t)return{};var e,n,o=function(t,i){if(null==t)return{};var e,n,o={},r=Object.keys(t);for(n=0;n<r.length;n++)e=r[n],i.indexOf(e)>=0||(o[e]=t[e]);return o}(t,i);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(t);for(n=0;n<r.length;n++)e=r[n],i.indexOf(e)>=0||Object.prototype.propertyIsEnumerable.call(t,e)&&(o[e]=t[e])}return o}var a=n.createContext({}),c=function(t){var i=n.useContext(a),e=i;return t&&(e="function"==typeof t?t(i):s(s({},i),t)),e},h=function(t){var i=c(t.components);return n.createElement(a.Provider,{value:i},t.children)},g="mdxType",u={inlineCode:"code",wrapper:function(t){var i=t.children;return n.createElement(n.Fragment,{},i)}},p=n.forwardRef((function(t,i){var e=t.components,o=t.mdxType,r=t.originalType,a=t.parentName,h=l(t,["components","mdxType","originalType","parentName"]),g=c(e),p=o,d=g["".concat(a,".").concat(p)]||g[p]||u[p]||r;return e?n.createElement(d,s(s({ref:i},h),{},{components:e})):n.createElement(d,s({ref:i},h))}));function d(t,i){var e=arguments,o=i&&i.mdxType;if("string"==typeof t||o){var r=e.length,s=new Array(r);s[0]=p;var l={};for(var a in i)hasOwnProperty.call(i,a)&&(l[a]=i[a]);l.originalType=t,l[g]="string"==typeof t?t:o,s[1]=l;for(var c=2;c<r;c++)s[c]=e[c];return n.createElement.apply(null,s)}return n.createElement.apply(null,e)}p.displayName="MDXCreateElement"},24808:(t,i,e)=>{e.d(i,{D5:()=>s});var n=e(67294),o=e(83156);e(9547),e(38826),e(81255),e(37442),e(4432),e(6415),e(90552),e(33855),e(46176),e(38824),e(31592);const r=e.e(4613).then(e.t.bind(e,24613,23)),s=n.forwardRef((function(t,i){return(0,o.Z)(t,i,r)}))},78542:(t,i,e)=>{function n(t){let i=1/0,e=1/0,n=1/0,o=-1/0,r=-1/0,s=-1/0;const l=t.POSITION?t.POSITION.value:[],a=l&&l.length;for(let c=0;c<a;c+=3){const t=l[c],a=l[c+1],h=l[c+2];i=t<i?t:i,e=a<e?a:e,n=h<n?h:n,o=t>o?t:o,r=a>r?a:r,s=h>s?h:s}return[[i,e,n],[o,r,s]]}e.d(i,{v:()=>n})},41708:(t,i,e)=>{e.d(i,{Z:()=>r});var n=e(60326),o=e(67532);class r{id;topology;vertexCount;indices;attributes;userData={};constructor(t){const{attributes:i={},indices:e=null,vertexCount:r=null}=t;this.id=t.id||(0,n.h)("geometry"),this.topology=t.topology,e&&(this.indices=ArrayBuffer.isView(e)?{value:e,size:1}:e),this.attributes={};for(const[n,s]of Object.entries(i)){const t=ArrayBuffer.isView(s)?{value:s}:s;(0,o.h)(ArrayBuffer.isView(t.value),`${this._print(n)}: must be typed array or object with value as typed array`),"POSITION"!==n&&"positions"!==n||t.size||(t.size=3),"indices"===n?((0,o.h)(!this.indices),this.indices=t):this.attributes[n]=t}this.indices&&void 0!==this.indices.isIndexed&&(this.indices=Object.assign({},this.indices),delete this.indices.isIndexed),this.vertexCount=r||this._calculateVertexCount(this.attributes,this.indices)}getVertexCount(){return this.vertexCount}getAttributes(){return this.indices?{indices:this.indices,...this.attributes}:this.attributes}_print(t){return`Geometry ${this.id} attribute ${t}`}_setAttributes(t,i){return this}_calculateVertexCount(t,i){if(i)return i.value.length;let e=1/0;for(const n of Object.values(t)){const{value:t,size:i,constant:o}=n;!o&&t&&i>=1&&(e=Math.min(e,t.length/i))}return(0,o.h)(Number.isFinite(e)),e}}},42013:(t,i,e)=>{e.d(i,{H:()=>s});const n="#if (defined(SHADER_TYPE_FRAGMENT) && defined(LIGHTING_FRAGMENT)) || (defined(SHADER_TYPE_VERTEX) && defined(LIGHTING_VERTEX))\nstruct AmbientLight {\nvec3 color;\n};\nstruct PointLight {\nvec3 color;\nvec3 position;\nvec3 attenuation;\n};\nstruct DirectionalLight {\nvec3 color;\nvec3 direction;\n};\nuniform AmbientLight lighting_uAmbientLight;\nuniform PointLight lighting_uPointLight[MAX_LIGHTS];\nuniform DirectionalLight lighting_uDirectionalLight[MAX_LIGHTS];\nuniform int lighting_uPointLightCount;\nuniform int lighting_uDirectionalLightCount;\nuniform bool lighting_uEnabled;\nfloat getPointLightAttenuation(PointLight pointLight, float distance) {\nreturn pointLight.attenuation.x\n+ pointLight.attenuation.y * distance\n+ pointLight.attenuation.z * distance * distance;\n}\n#endif\n",o={lightSources:{}};function r(t={}){const{color:i=[0,0,0],intensity:e=1}=t;return i.map((t=>t*e/255))}const s={name:"lights",vs:n,fs:n,getUniforms:function t(i=o){if("lightSources"in i){const{ambientLight:t,pointLights:e,directionalLights:n}=i.lightSources||{};return t||e&&e.length>0||n&&n.length>0?Object.assign({},function({ambientLight:t,pointLights:i=[],directionalLights:e=[]}){const n={};return n["lighting_uAmbientLight.color"]=t?r(t):[0,0,0],i.forEach(((t,i)=>{n[`lighting_uPointLight[${i}].color`]=r(t),n[`lighting_uPointLight[${i}].position`]=t.position,n[`lighting_uPointLight[${i}].attenuation`]=t.attenuation||[1,0,0]})),n.lighting_uPointLightCount=i.length,e.forEach(((t,i)=>{n[`lighting_uDirectionalLight[${i}].color`]=r(t),n[`lighting_uDirectionalLight[${i}].direction`]=t.direction})),n.lighting_uDirectionalLightCount=e.length,n}({ambientLight:t,pointLights:e,directionalLights:n}),{lighting_uEnabled:!0}):{lighting_uEnabled:!1}}if("lights"in i){const e={pointLights:[],directionalLights:[]};for(const t of i.lights||[])switch(t.type){case"ambient":e.ambientLight=t;break;case"directional":e.directionalLights?.push(t);break;case"point":e.pointLights?.push(t)}return t({lightSources:e})}return{}},defines:{MAX_LIGHTS:3}}},55098:(t,i,e)=>{e.d(i,{N:()=>l,s:()=>a});var n=e(42013);const o="uniform float lighting_uAmbient;\nuniform float lighting_uDiffuse;\nuniform float lighting_uShininess;\nuniform vec3  lighting_uSpecularColor;\nvec3 lighting_getLightColor(vec3 surfaceColor, vec3 light_direction, vec3 view_direction, vec3 normal_worldspace, vec3 color) {\nvec3 halfway_direction = normalize(light_direction + view_direction);\nfloat lambertian = dot(light_direction, normal_worldspace);\nfloat specular = 0.0;\nif (lambertian > 0.0) {\nfloat specular_angle = max(dot(normal_worldspace, halfway_direction), 0.0);\nspecular = pow(specular_angle, lighting_uShininess);\n}\nlambertian = max(lambertian, 0.0);\nreturn (lambertian * lighting_uDiffuse * surfaceColor + specular * lighting_uSpecularColor) * color;\n}\nvec3 lighting_getLightColor(vec3 surfaceColor, vec3 cameraPosition, vec3 position_worldspace, vec3 normal_worldspace) {\nvec3 lightColor = surfaceColor;\nif (lighting_uEnabled) {\nvec3 view_direction = normalize(cameraPosition - position_worldspace);\nlightColor = lighting_uAmbient * surfaceColor * lighting_uAmbientLight.color;\nfor (int i = 0; i < MAX_LIGHTS; i++) {\nif (i >= lighting_uPointLightCount) {\nbreak;\n}\nPointLight pointLight = lighting_uPointLight[i];\nvec3 light_position_worldspace = pointLight.position;\nvec3 light_direction = normalize(light_position_worldspace - position_worldspace);\nlightColor += lighting_getLightColor(surfaceColor, light_direction, view_direction, normal_worldspace, pointLight.color);\n}\nfor (int i = 0; i < MAX_LIGHTS; i++) {\nif (i >= lighting_uDirectionalLightCount) {\nbreak;\n}\nDirectionalLight directionalLight = lighting_uDirectionalLight[i];\nlightColor += lighting_getLightColor(surfaceColor, -directionalLight.direction, view_direction, normal_worldspace, directionalLight.color);\n}\n}\nreturn lightColor;\n}\nvec3 lighting_getSpecularLightColor(vec3 cameraPosition, vec3 position_worldspace, vec3 normal_worldspace) {\nvec3 lightColor = vec3(0, 0, 0);\nvec3 surfaceColor = vec3(0, 0, 0);\nif (lighting_uEnabled) {\nvec3 view_direction = normalize(cameraPosition - position_worldspace);\nfor (int i = 0; i < MAX_LIGHTS; i++) {\nif (i >= lighting_uPointLightCount) {\nbreak;\n}\nPointLight pointLight = lighting_uPointLight[i];\nvec3 light_position_worldspace = pointLight.position;\nvec3 light_direction = normalize(light_position_worldspace - position_worldspace);\nlightColor += lighting_getLightColor(surfaceColor, light_direction, view_direction, normal_worldspace, pointLight.color);\n}\nfor (int i = 0; i < MAX_LIGHTS; i++) {\nif (i >= lighting_uDirectionalLightCount) {\nbreak;\n}\nDirectionalLight directionalLight = lighting_uDirectionalLight[i];\nlightColor += lighting_getLightColor(surfaceColor, -directionalLight.direction, view_direction, normal_worldspace, directionalLight.color);\n}\n}\nreturn lightColor;\n}\n",r={};function s(t=r){if(!("material"in t))return{};const{material:i}=t;return i?function(t){const{ambient:i=.35,diffuse:e=.6,shininess:n=32,specularColor:o=[30,30,30]}=t;return{lighting_uAmbient:i,lighting_uDiffuse:e,lighting_uShininess:n,lighting_uSpecularColor:o.map((t=>t/255))}}(i):{lighting_uEnabled:!1}}const l={name:"gouraud-lighting",dependencies:[n.H],vs:o,defines:{LIGHTING_VERTEX:1},getUniforms:s},a={name:"phong-lighting",dependencies:[n.H],fs:o,defines:{LIGHTING_FRAGMENT:1},getUniforms:s}},35300:(t,i,e)=>{e.d(i,{q:()=>o});const n=new Float32Array([0,1,1,1]),o={name:"picking",vs:"uniform pickingUniforms {\nfloat isActive;\nfloat isAttribute;\nfloat isHighlightActive;\nfloat useFloatColors;\nvec3 highlightedObjectColor;\nvec4 highlightColor;\n} picking;\nout vec4 picking_vRGBcolor_Avalid;\nvec3 picking_normalizeColor(vec3 color) {\nreturn picking.useFloatColors > 0.5 ? color : color / 255.0;\n}\nvec4 picking_normalizeColor(vec4 color) {\nreturn picking.useFloatColors > 0.5 ? color : color / 255.0;\n}\nbool picking_isColorZero(vec3 color) {\nreturn dot(color, vec3(1.0)) < 0.00001;\n}\nbool picking_isColorValid(vec3 color) {\nreturn dot(color, vec3(1.0)) > 0.00001;\n}\nbool isVertexHighlighted(vec3 vertexColor) {\nvec3 highlightedObjectColor = picking_normalizeColor(picking.highlightedObjectColor);\nreturn\nbool(picking.isHighlightActive) && picking_isColorZero(abs(vertexColor - highlightedObjectColor));\n}\nvoid picking_setPickingColor(vec3 pickingColor) {\npickingColor = picking_normalizeColor(pickingColor);\nif (bool(picking.isActive)) {\npicking_vRGBcolor_Avalid.a = float(picking_isColorValid(pickingColor));\npicking_vRGBcolor_Avalid.rgb = pickingColor;\n} else {\npicking_vRGBcolor_Avalid.a = float(isVertexHighlighted(pickingColor));\n}\n}\nvoid picking_setPickingAttribute(float value) {\nif (bool(picking.isAttribute)) {\npicking_vRGBcolor_Avalid.r = value;\n}\n}\nvoid picking_setPickingAttribute(vec2 value) {\nif (bool(picking.isAttribute)) {\npicking_vRGBcolor_Avalid.rg = value;\n}\n}\nvoid picking_setPickingAttribute(vec3 value) {\nif (bool(picking.isAttribute)) {\npicking_vRGBcolor_Avalid.rgb = value;\n}\n}\n",fs:"uniform pickingUniforms {\nfloat isActive;\nfloat isAttribute;\nfloat isHighlightActive;\nfloat useFloatColors;\nvec3 highlightedObjectColor;\nvec4 highlightColor;\n} picking;\nin vec4 picking_vRGBcolor_Avalid;\nvec4 picking_filterHighlightColor(vec4 color) {\nif (picking.isActive > 0.5) {\nreturn color;\n}\nbool selected = bool(picking_vRGBcolor_Avalid.a);\nif (selected) {\nfloat highLightAlpha = picking.highlightColor.a;\nfloat blendedAlpha = highLightAlpha + color.a * (1.0 - highLightAlpha);\nfloat highLightRatio = highLightAlpha / blendedAlpha;\nvec3 blendedRGB = mix(color.rgb, picking.highlightColor.rgb, highLightRatio);\nreturn vec4(blendedRGB, blendedAlpha);\n} else {\nreturn color;\n}\n}\nvec4 picking_filterPickingColor(vec4 color) {\nif (bool(picking.isActive)) {\nif (picking_vRGBcolor_Avalid.a == 0.0) {\ndiscard;\n}\nreturn picking_vRGBcolor_Avalid;\n}\nreturn color;\n}\nvec4 picking_filterColor(vec4 color) {\nvec4 highlightColor = picking_filterHighlightColor(color);\nreturn picking_filterPickingColor(highlightColor);\n}\n",uniformTypes:{isActive:"f32",isAttribute:"f32",isHighlightActive:"f32",useFloatColors:"f32",highlightedObjectColor:"vec3<f32>",highlightColor:"vec4<f32>"},defaultUniforms:{isActive:!1,isAttribute:!1,isHighlightActive:!1,useFloatColors:!0,highlightedObjectColor:new Float32Array([0,0,0]),highlightColor:n},getUniforms:function(t={},i){const e={};if(void 0===t.highlightedObjectColor);else if(null===t.highlightedObjectColor)e.isHighlightActive=!1;else{e.isHighlightActive=!0;const i=t.highlightedObjectColor.slice(0,3);e.highlightedObjectColor=i}if(t.highlightColor){const i=Array.from(t.highlightColor,(t=>t/255));Number.isFinite(i[3])||(i[3]=1),e.highlightColor=i}void 0!==t.isActive&&(e.isActive=Boolean(t.isActive),e.isAttribute=Boolean(t.isAttribute));void 0!==t.useFloatColors&&(e.useFloatColors=Boolean(t.useFloatColors));return e}}},25825:(t,i,e)=>{e.d(i,{LU:()=>v});var n=e(78542);const o=/^[og]\s*(.+)?/,r=/^mtllib /,s=/^usemtl /;class l{constructor(t){let{index:i,name:e="",mtllib:n,smooth:o,groupStart:r}=t;this.index=i,this.name=e,this.mtllib=n,this.smooth=o,this.groupStart=r,this.groupEnd=-1,this.groupCount=-1,this.inherited=!1}clone(){let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:this.index;return new l({index:t,name:this.name,mtllib:this.mtllib,smooth:this.smooth,groupStart:0})}}class a{constructor(){let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:"";this.name=t,this.geometry={vertices:[],normals:[],colors:[],uvs:[]},this.materials=[],this.smooth=!0,this.fromDeclaration=null}startMaterial(t,i){const e=this._finalize(!1);e&&(e.inherited||e.groupCount<=0)&&this.materials.splice(e.index,1);const n=new l({index:this.materials.length,name:t,mtllib:Array.isArray(i)&&i.length>0?i[i.length-1]:"",smooth:void 0!==e?e.smooth:this.smooth,groupStart:void 0!==e?e.groupEnd:0});return this.materials.push(n),n}currentMaterial(){if(this.materials.length>0)return this.materials[this.materials.length-1]}_finalize(t){const i=this.currentMaterial();if(i&&-1===i.groupEnd&&(i.groupEnd=this.geometry.vertices.length/3,i.groupCount=i.groupEnd-i.groupStart,i.inherited=!1),t&&this.materials.length>1)for(let e=this.materials.length-1;e>=0;e--)this.materials[e].groupCount<=0&&this.materials.splice(e,1);return t&&0===this.materials.length&&this.materials.push({name:"",smooth:this.smooth}),i}}class c{constructor(){this.objects=[],this.object=null,this.vertices=[],this.normals=[],this.colors=[],this.uvs=[],this.materialLibraries=[],this.startObject("",!1)}startObject(t){let i=!(arguments.length>1&&void 0!==arguments[1])||arguments[1];if(this.object&&!this.object.fromDeclaration)return this.object.name=t,void(this.object.fromDeclaration=i);const e=this.object&&"function"==typeof this.object.currentMaterial?this.object.currentMaterial():void 0;if(this.object&&"function"==typeof this.object._finalize&&this.object._finalize(!0),this.object=new a(t),this.object.fromDeclaration=i,e&&e.name&&"function"==typeof e.clone){const t=e.clone(0);t.inherited=!0,this.object.materials.push(t)}this.objects.push(this.object)}finalize(){this.object&&"function"==typeof this.object._finalize&&this.object._finalize(!0)}parseVertexIndex(t,i){const e=parseInt(t);return 3*(e>=0?e-1:e+i/3)}parseNormalIndex(t,i){const e=parseInt(t);return 3*(e>=0?e-1:e+i/3)}parseUVIndex(t,i){const e=parseInt(t);return 2*(e>=0?e-1:e+i/2)}addVertex(t,i,e){const n=this.vertices,o=this.object.geometry.vertices;o.push(n[t+0],n[t+1],n[t+2]),o.push(n[i+0],n[i+1],n[i+2]),o.push(n[e+0],n[e+1],n[e+2])}addVertexPoint(t){const i=this.vertices;this.object.geometry.vertices.push(i[t+0],i[t+1],i[t+2])}addVertexLine(t){const i=this.vertices;this.object.geometry.vertices.push(i[t+0],i[t+1],i[t+2])}addNormal(t,i,e){const n=this.normals,o=this.object.geometry.normals;o.push(n[t+0],n[t+1],n[t+2]),o.push(n[i+0],n[i+1],n[i+2]),o.push(n[e+0],n[e+1],n[e+2])}addColor(t,i,e){const n=this.colors,o=this.object.geometry.colors;o.push(n[t+0],n[t+1],n[t+2]),o.push(n[i+0],n[i+1],n[i+2]),o.push(n[e+0],n[e+1],n[e+2])}addUV(t,i,e){const n=this.uvs,o=this.object.geometry.uvs;o.push(n[t+0],n[t+1]),o.push(n[i+0],n[i+1]),o.push(n[e+0],n[e+1])}addUVLine(t){const i=this.uvs;this.object.geometry.uvs.push(i[t+0],i[t+1])}addFace(t,i,e,n,o,r,s,l,a){const c=this.vertices.length;let h=this.parseVertexIndex(t,c),g=this.parseVertexIndex(i,c),u=this.parseVertexIndex(e,c);if(this.addVertex(h,g,u),void 0!==n&&""!==n){const t=this.uvs.length;h=this.parseUVIndex(n,t),g=this.parseUVIndex(o,t),u=this.parseUVIndex(r,t),this.addUV(h,g,u)}if(void 0!==s&&""!==s){const t=this.normals.length;h=this.parseNormalIndex(s,t),g=s===l?h:this.parseNormalIndex(l,t),u=s===a?h:this.parseNormalIndex(a,t),this.addNormal(h,g,u)}this.colors.length>0&&this.addColor(h,g,u)}addPointGeometry(t){this.object.geometry.type="Points";const i=this.vertices.length;for(const e of t)this.addVertexPoint(this.parseVertexIndex(e,i))}addLineGeometry(t,i){this.object.geometry.type="Line";const e=this.vertices.length,n=this.uvs.length;for(const o of t)this.addVertexLine(this.parseVertexIndex(o,e));for(const o of i)this.addUVLine(this.parseUVIndex(o,n))}}var h=e(75177);function g(t,i){const e={};for(const o in i)"value"!==o&&(e[o]=JSON.stringify(i[o]));let{type:n}=(0,h.gU)(i.value);return 1===i.size||void 0===i.size||(n={type:"fixed-size-list",listSize:i.size,children:[{name:"values",type:n}]}),{name:t,type:n,nullable:!1,metadata:e}}function u(t,i){const{meshes:e}=function(t){const i=new c;-1!==t.indexOf("\r\n")&&(t=t.replace(/\r\n/g,"\n")),-1!==t.indexOf("\\\n")&&(t=t.replace(/\\\n/g,""));const e=t.split("\n");let n="",l="",a=0,h=[];const g="function"==typeof"".trimLeft;for(let c=0,d=e.length;c<d;c++)if(n=e[c],n=g?n.trimLeft():n.trim(),a=n.length,0!==a&&(l=n.charAt(0),"#"!==l))if("v"===l){const t=n.split(/\s+/);switch(t[0]){case"v":i.vertices.push(parseFloat(t[1]),parseFloat(t[2]),parseFloat(t[3])),t.length>=7&&i.colors.push(parseFloat(t[4]),parseFloat(t[5]),parseFloat(t[6]));break;case"vn":i.normals.push(parseFloat(t[1]),parseFloat(t[2]),parseFloat(t[3]));break;case"vt":i.uvs.push(parseFloat(t[1]),parseFloat(t[2]))}}else if("f"===l){const t=n.substr(1).trim().split(/\s+/),e=[];for(let i=0,n=t.length;i<n;i++){const n=t[i];if(n.length>0){const t=n.split("/");e.push(t)}}const o=e[0];for(let n=1,r=e.length-1;n<r;n++){const t=e[n],r=e[n+1];i.addFace(o[0],t[0],r[0],o[1],t[1],r[1],o[2],t[2],r[2])}}else if("l"===l){const t=n.substring(1).trim().split(" ");let e;const o=[];if(-1===n.indexOf("/"))e=t;else{e=[];for(let i=0,n=t.length;i<n;i++){const n=t[i].split("/");""!==n[0]&&e.push(n[0]),""!==n[1]&&o.push(n[1])}}i.addLineGeometry(e,o)}else if("p"===l){const t=n.substr(1).trim().split(" ");i.addPointGeometry(t)}else if(null!==(h=o.exec(n))){const t=(" "+h[0].substr(1).trim()).substr(1);i.startObject(t)}else if(s.test(n))i.object.startMaterial(n.substring(7).trim(),i.materialLibraries);else if(r.test(n))i.materialLibraries.push(n.substring(7).trim());else{if("s"!==l){if("\0"===n)continue;throw new Error(`Unexpected line: "${n}"`)}{if(h=n.split(" "),h.length>1){const t=h[1].trim().toLowerCase();i.object.smooth="0"!==t&&"off"!==t}else i.object.smooth=!0;const t=i.object.currentMaterial();t&&(t.smooth=i.object.smooth)}}i.finalize();const u=[],p=[];for(const o of i.objects){const{geometry:t}=o;if(0===t.vertices.length)continue;const i={header:{vertexCount:t.vertices.length/3},attributes:{}};switch(t.type){case"Points":i.mode=0;break;case"Line":i.mode=1;break;default:i.mode=4}i.attributes.POSITION={value:new Float32Array(t.vertices),size:3},t.normals.length>0&&(i.attributes.NORMAL={value:new Float32Array(t.normals),size:3}),t.colors.length>0&&(i.attributes.COLOR_0={value:new Float32Array(t.colors),size:3}),t.uvs.length>0&&(i.attributes.TEXCOORD_0={value:new Float32Array(t.uvs),size:2}),i.materials=[];for(const e of o.materials){const t={name:e.name,flatShading:!e.smooth};i.materials.push(t),p.push(t)}i.name=o.name,u.push(i)}return{meshes:u,materials:p}}(t),l=e.reduce(((t,i)=>t+i.header.vertexCount),0),a=function(t,i){const e=new Float32Array(3*i);let n,o,r,s=0;for(const a of t){const{POSITION:t,NORMAL:l,COLOR_0:c,TEXCOORD_0:h}=a.attributes;e.set(t.value,3*s),l&&(n=n||new Float32Array(3*i),n.set(l.value,3*s)),c&&(o=o||new Float32Array(3*i),o.set(c.value,3*s)),h&&(r=r||new Float32Array(2*i),r.set(h.value,2*s)),s+=t.value.length/3}const l={};l.POSITION={value:e,size:3},n&&(l.NORMAL={value:n,size:3});o&&(l.COLOR_0={value:o,size:3});r&&(l.TEXCOORD_0={value:r,size:2});return l}(e,l),h={vertexCount:l,boundingBox:(0,n.v)(a)},u=function(t){let i=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};const e={};for(const o in i)"value"!==o&&(e[o]=JSON.stringify(i[o]));const n=[];for(const o in t){const i=g(o,t[o]);n.push(i)}return{fields:n,metadata:e}}(a,{mode:4,boundingBox:h.boundingBox});return{loaderData:{header:{}},schema:u,header:h,mode:4,topology:"point-list",attributes:a}}const p=/\s+/;function d(t,i){const e=[];let n={name:"placeholder"};const o=t.split("\n");for(let r of o){if(r=r.trim(),0===r.length||"#"===r.charAt(0))continue;const t=r.indexOf(" ");let i=t>=0?r.substring(0,t):r;i=i.toLowerCase();let o=t>=0?r.substring(t+1):"";switch(o=o.trim(),i){case"newmtl":n={name:o},e.push(n);break;case"ka":n.ambientColor=f(o);break;case"kd":n.diffuseColor=f(o);break;case"map_kd":n.diffuseTextureUrl=o;break;case"ks":n.specularColor=f(o);break;case"map_ks":n.specularTextureUrl=o;break;case"ke":n.emissiveColor=f(o);break;case"map_ke":n.emissiveTextureUrl=o;break;case"ns":n.shininess=parseFloat(o);break;case"map_ns":default:break;case"ni":n.refraction=parseFloat(o);break;case"illum":n.illumination=parseFloat(o)}}return e}function f(t,i){const e=t.split(p,3);return[parseFloat(e[0]),parseFloat(e[1]),parseFloat(e[2])]}const v={...{name:"OBJ",id:"obj",module:"obj",version:"4.1.4",worker:!0,extensions:["obj"],mimeTypes:["text/plain"],testText:function(t){return"v"===t[0]},options:{obj:{}}},parse:async(t,i)=>u((new TextDecoder).decode(t)),parseTextSync:(t,i)=>u(t)}}}]);