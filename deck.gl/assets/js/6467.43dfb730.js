"use strict";(self.webpackChunkproject_website=self.webpackChunkproject_website||[]).push([[6467],{3905:(i,t,e)=>{e.d(t,{Zo:()=>h,kt:()=>f});var n=e(67294);function o(i,t,e){return t in i?Object.defineProperty(i,t,{value:e,enumerable:!0,configurable:!0,writable:!0}):i[t]=e,i}function r(i,t){var e=Object.keys(i);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(i);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(i,t).enumerable}))),e.push.apply(e,n)}return e}function l(i){for(var t=1;t<arguments.length;t++){var e=null!=arguments[t]?arguments[t]:{};t%2?r(Object(e),!0).forEach((function(t){o(i,t,e[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(i,Object.getOwnPropertyDescriptors(e)):r(Object(e)).forEach((function(t){Object.defineProperty(i,t,Object.getOwnPropertyDescriptor(e,t))}))}return i}function c(i,t){if(null==i)return{};var e,n,o=function(i,t){if(null==i)return{};var e,n,o={},r=Object.keys(i);for(n=0;n<r.length;n++)e=r[n],t.indexOf(e)>=0||(o[e]=i[e]);return o}(i,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(i);for(n=0;n<r.length;n++)e=r[n],t.indexOf(e)>=0||Object.prototype.propertyIsEnumerable.call(i,e)&&(o[e]=i[e])}return o}var g=n.createContext({}),s=function(i){var t=n.useContext(g),e=t;return i&&(e="function"==typeof i?i(t):l(l({},t),i)),e},h=function(i){var t=s(i.components);return n.createElement(g.Provider,{value:t},i.children)},a="mdxType",u={inlineCode:"code",wrapper:function(i){var t=i.children;return n.createElement(n.Fragment,{},t)}},p=n.forwardRef((function(i,t){var e=i.components,o=i.mdxType,r=i.originalType,g=i.parentName,h=c(i,["components","mdxType","originalType","parentName"]),a=s(e),p=o,f=a["".concat(g,".").concat(p)]||a[p]||u[p]||r;return e?n.createElement(f,l(l({ref:t},h),{},{components:e})):n.createElement(f,l({ref:t},h))}));function f(i,t){var e=arguments,o=t&&t.mdxType;if("string"==typeof i||o){var r=e.length,l=new Array(r);l[0]=p;var c={};for(var g in t)hasOwnProperty.call(t,g)&&(c[g]=t[g]);c.originalType=i,c[a]="string"==typeof i?i:o,l[1]=c;for(var s=2;s<r;s++)l[s]=e[s];return n.createElement.apply(null,l)}return n.createElement.apply(null,e)}p.displayName="MDXCreateElement"},20745:(i,t,e)=>{var n=e(73935);t.s=n.createRoot,n.hydrateRoot},24808:(i,t,e)=>{e.d(t,{D5:()=>l});var n=e(67294),o=e(83156);e(9547),e(38826),e(81255),e(37442),e(4432),e(6415),e(90552),e(33855),e(46176),e(38824),e(31592);const r=e.e(4613).then(e.t.bind(e,24613,23)),l=n.forwardRef((function(i,t){return(0,o.Z)(i,t,r)}))},78542:(i,t,e)=>{function n(i){let t=1/0,e=1/0,n=1/0,o=-1/0,r=-1/0,l=-1/0;const c=i.POSITION?i.POSITION.value:[],g=c&&c.length;for(let s=0;s<g;s+=3){const i=c[s],g=c[s+1],h=c[s+2];t=i<t?i:t,e=g<e?g:e,n=h<n?h:n,o=i>o?i:o,r=g>r?g:r,l=h>l?h:l}return[[t,e,n],[o,r,l]]}e.d(t,{v:()=>n})},41708:(i,t,e)=>{e.d(t,{Z:()=>r});var n=e(60326),o=e(67532);class r{id;topology;vertexCount;indices;attributes;userData={};constructor(i){const{attributes:t={},indices:e=null,vertexCount:r=null}=i;this.id=i.id||(0,n.h)("geometry"),this.topology=i.topology,e&&(this.indices=ArrayBuffer.isView(e)?{value:e,size:1}:e),this.attributes={};for(const[n,l]of Object.entries(t)){const i=ArrayBuffer.isView(l)?{value:l}:l;(0,o.h)(ArrayBuffer.isView(i.value),`${this._print(n)}: must be typed array or object with value as typed array`),"POSITION"!==n&&"positions"!==n||i.size||(i.size=3),"indices"===n?((0,o.h)(!this.indices),this.indices=i):this.attributes[n]=i}this.indices&&void 0!==this.indices.isIndexed&&(this.indices=Object.assign({},this.indices),delete this.indices.isIndexed),this.vertexCount=r||this._calculateVertexCount(this.attributes,this.indices)}getVertexCount(){return this.vertexCount}getAttributes(){return this.indices?{indices:this.indices,...this.attributes}:this.attributes}_print(i){return`Geometry ${this.id} attribute ${i}`}_setAttributes(i,t){return this}_calculateVertexCount(i,t){if(t)return t.value.length;let e=1/0;for(const n of Object.values(i)){const{value:i,size:t,constant:o}=n;!o&&i&&t>=1&&(e=Math.min(e,i.length/t))}return(0,o.h)(Number.isFinite(e)),e}}},42013:(i,t,e)=>{e.d(t,{H:()=>l});const n="#if (defined(SHADER_TYPE_FRAGMENT) && defined(LIGHTING_FRAGMENT)) || (defined(SHADER_TYPE_VERTEX) && defined(LIGHTING_VERTEX))\nstruct AmbientLight {\nvec3 color;\n};\nstruct PointLight {\nvec3 color;\nvec3 position;\nvec3 attenuation;\n};\nstruct DirectionalLight {\nvec3 color;\nvec3 direction;\n};\nuniform AmbientLight lighting_uAmbientLight;\nuniform PointLight lighting_uPointLight[MAX_LIGHTS];\nuniform DirectionalLight lighting_uDirectionalLight[MAX_LIGHTS];\nuniform int lighting_uPointLightCount;\nuniform int lighting_uDirectionalLightCount;\nuniform bool lighting_uEnabled;\nfloat getPointLightAttenuation(PointLight pointLight, float distance) {\nreturn pointLight.attenuation.x\n+ pointLight.attenuation.y * distance\n+ pointLight.attenuation.z * distance * distance;\n}\n#endif\n",o={lightSources:{}};function r(i={}){const{color:t=[0,0,0],intensity:e=1}=i;return t.map((i=>i*e/255))}const l={name:"lights",vs:n,fs:n,getUniforms:function i(t=o){if("lightSources"in t){const{ambientLight:i,pointLights:e,directionalLights:n}=t.lightSources||{};return i||e&&e.length>0||n&&n.length>0?Object.assign({},function({ambientLight:i,pointLights:t=[],directionalLights:e=[]}){const n={};return n["lighting_uAmbientLight.color"]=i?r(i):[0,0,0],t.forEach(((i,t)=>{n[`lighting_uPointLight[${t}].color`]=r(i),n[`lighting_uPointLight[${t}].position`]=i.position,n[`lighting_uPointLight[${t}].attenuation`]=i.attenuation||[1,0,0]})),n.lighting_uPointLightCount=t.length,e.forEach(((i,t)=>{n[`lighting_uDirectionalLight[${t}].color`]=r(i),n[`lighting_uDirectionalLight[${t}].direction`]=i.direction})),n.lighting_uDirectionalLightCount=e.length,n}({ambientLight:i,pointLights:e,directionalLights:n}),{lighting_uEnabled:!0}):{lighting_uEnabled:!1}}if("lights"in t){const e={pointLights:[],directionalLights:[]};for(const i of t.lights||[])switch(i.type){case"ambient":e.ambientLight=i;break;case"directional":e.directionalLights?.push(i);break;case"point":e.pointLights?.push(i)}return i({lightSources:e})}return{}},defines:{MAX_LIGHTS:3}}},35300:(i,t,e)=>{e.d(t,{q:()=>o});const n=new Float32Array([0,1,1,1]),o={name:"picking",vs:"uniform pickingUniforms {\nfloat isActive;\nfloat isAttribute;\nfloat isHighlightActive;\nfloat useFloatColors;\nvec3 highlightedObjectColor;\nvec4 highlightColor;\n} picking;\nout vec4 picking_vRGBcolor_Avalid;\nvec3 picking_normalizeColor(vec3 color) {\nreturn picking.useFloatColors > 0.5 ? color : color / 255.0;\n}\nvec4 picking_normalizeColor(vec4 color) {\nreturn picking.useFloatColors > 0.5 ? color : color / 255.0;\n}\nbool picking_isColorZero(vec3 color) {\nreturn dot(color, vec3(1.0)) < 0.00001;\n}\nbool picking_isColorValid(vec3 color) {\nreturn dot(color, vec3(1.0)) > 0.00001;\n}\nbool isVertexHighlighted(vec3 vertexColor) {\nvec3 highlightedObjectColor = picking_normalizeColor(picking.highlightedObjectColor);\nreturn\nbool(picking.isHighlightActive) && picking_isColorZero(abs(vertexColor - highlightedObjectColor));\n}\nvoid picking_setPickingColor(vec3 pickingColor) {\npickingColor = picking_normalizeColor(pickingColor);\nif (bool(picking.isActive)) {\npicking_vRGBcolor_Avalid.a = float(picking_isColorValid(pickingColor));\npicking_vRGBcolor_Avalid.rgb = pickingColor;\n} else {\npicking_vRGBcolor_Avalid.a = float(isVertexHighlighted(pickingColor));\n}\n}\nvoid picking_setPickingAttribute(float value) {\nif (bool(picking.isAttribute)) {\npicking_vRGBcolor_Avalid.r = value;\n}\n}\nvoid picking_setPickingAttribute(vec2 value) {\nif (bool(picking.isAttribute)) {\npicking_vRGBcolor_Avalid.rg = value;\n}\n}\nvoid picking_setPickingAttribute(vec3 value) {\nif (bool(picking.isAttribute)) {\npicking_vRGBcolor_Avalid.rgb = value;\n}\n}\n",fs:"uniform pickingUniforms {\nfloat isActive;\nfloat isAttribute;\nfloat isHighlightActive;\nfloat useFloatColors;\nvec3 highlightedObjectColor;\nvec4 highlightColor;\n} picking;\nin vec4 picking_vRGBcolor_Avalid;\nvec4 picking_filterHighlightColor(vec4 color) {\nif (picking.isActive > 0.5) {\nreturn color;\n}\nbool selected = bool(picking_vRGBcolor_Avalid.a);\nif (selected) {\nfloat highLightAlpha = picking.highlightColor.a;\nfloat blendedAlpha = highLightAlpha + color.a * (1.0 - highLightAlpha);\nfloat highLightRatio = highLightAlpha / blendedAlpha;\nvec3 blendedRGB = mix(color.rgb, picking.highlightColor.rgb, highLightRatio);\nreturn vec4(blendedRGB, blendedAlpha);\n} else {\nreturn color;\n}\n}\nvec4 picking_filterPickingColor(vec4 color) {\nif (bool(picking.isActive)) {\nif (picking_vRGBcolor_Avalid.a == 0.0) {\ndiscard;\n}\nreturn picking_vRGBcolor_Avalid;\n}\nreturn color;\n}\nvec4 picking_filterColor(vec4 color) {\nvec4 highlightColor = picking_filterHighlightColor(color);\nreturn picking_filterPickingColor(highlightColor);\n}\n",uniformTypes:{isActive:"f32",isAttribute:"f32",isHighlightActive:"f32",useFloatColors:"f32",highlightedObjectColor:"vec3<f32>",highlightColor:"vec4<f32>"},defaultUniforms:{isActive:!1,isAttribute:!1,isHighlightActive:!1,useFloatColors:!0,highlightedObjectColor:new Float32Array([0,0,0]),highlightColor:n},getUniforms:function(i={},t){const e={};if(void 0===i.highlightedObjectColor);else if(null===i.highlightedObjectColor)e.isHighlightActive=!1;else{e.isHighlightActive=!0;const t=i.highlightedObjectColor.slice(0,3);e.highlightedObjectColor=t}if(i.highlightColor){const t=Array.from(i.highlightColor,(i=>i/255));Number.isFinite(t[3])||(t[3]=1),e.highlightColor=t}void 0!==i.isActive&&(e.isActive=Boolean(i.isActive),e.isAttribute=Boolean(i.isAttribute));void 0!==i.useFloatColors&&(e.useFloatColors=Boolean(i.useFloatColors));return e}}}}]);