"use strict";(self.webpackChunkproject_website=self.webpackChunkproject_website||[]).push([[8748,2601,7142,1559,8446],{3905:(t,e,i)=>{i.d(e,{Zo:()=>l,kt:()=>f});var o=i(67294);function n(t,e,i){return e in t?Object.defineProperty(t,e,{value:i,enumerable:!0,configurable:!0,writable:!0}):t[e]=i,t}function r(t,e){var i=Object.keys(t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(t);e&&(o=o.filter((function(e){return Object.getOwnPropertyDescriptor(t,e).enumerable}))),i.push.apply(i,o)}return i}function s(t){for(var e=1;e<arguments.length;e++){var i=null!=arguments[e]?arguments[e]:{};e%2?r(Object(i),!0).forEach((function(e){n(t,e,i[e])})):Object.getOwnPropertyDescriptors?Object.defineProperties(t,Object.getOwnPropertyDescriptors(i)):r(Object(i)).forEach((function(e){Object.defineProperty(t,e,Object.getOwnPropertyDescriptor(i,e))}))}return t}function u(t,e){if(null==t)return{};var i,o,n=function(t,e){if(null==t)return{};var i,o,n={},r=Object.keys(t);for(o=0;o<r.length;o++)i=r[o],e.indexOf(i)>=0||(n[i]=t[i]);return n}(t,e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(t);for(o=0;o<r.length;o++)i=r[o],e.indexOf(i)>=0||Object.prototype.propertyIsEnumerable.call(t,i)&&(n[i]=t[i])}return n}var a=o.createContext({}),c=function(t){var e=o.useContext(a),i=e;return t&&(i="function"==typeof t?t(e):s(s({},e),t)),i},l=function(t){var e=c(t.components);return o.createElement(a.Provider,{value:e},t.children)},h="mdxType",p={inlineCode:"code",wrapper:function(t){var e=t.children;return o.createElement(o.Fragment,{},e)}},d=o.forwardRef((function(t,e){var i=t.components,n=t.mdxType,r=t.originalType,a=t.parentName,l=u(t,["components","mdxType","originalType","parentName"]),h=c(i),d=n,f=h["".concat(a,".").concat(d)]||h[d]||p[d]||r;return i?o.createElement(f,s(s({ref:e},l),{},{components:i})):o.createElement(f,s({ref:e},l))}));function f(t,e){var i=arguments,n=e&&e.mdxType;if("string"==typeof t||n){var r=i.length,s=new Array(r);s[0]=d;var u={};for(var a in e)hasOwnProperty.call(e,a)&&(u[a]=e[a]);u.originalType=t,u[h]="string"==typeof t?t:n,s[1]=u;for(var c=2;c<r;c++)s[c]=i[c];return o.createElement.apply(null,s)}return o.createElement.apply(null,i)}d.displayName="MDXCreateElement"},20745:(t,e,i)=>{var o=i(73935);e.s=o.createRoot,o.hydrateRoot},60850:(t,e,i)=>{function o(t,e,i,r,s,u){if(s-r<=i)return;const a=r+s>>1;n(t,e,a,r,s,u%2),o(t,e,i,r,a-1,u+1),o(t,e,i,a+1,s,u+1)}function n(t,e,i,o,s,u){for(;s>o;){if(s-o>600){const r=s-o+1,a=i-o+1,c=Math.log(r),l=.5*Math.exp(2*c/3),h=.5*Math.sqrt(c*l*(r-l)/r)*(a-r/2<0?-1:1);n(t,e,i,Math.max(o,Math.floor(i-a*l/r+h)),Math.min(s,Math.floor(i+(r-a)*l/r+h)),u)}const a=e[2*i+u];let c=o,l=s;for(r(t,e,o,i),e[2*s+u]>a&&r(t,e,o,s);c<l;){for(r(t,e,c,l),c++,l--;e[2*c+u]<a;)c++;for(;e[2*l+u]>a;)l--}e[2*o+u]===a?r(t,e,o,l):(l++,r(t,e,l,s)),l<=i&&(o=l+1),i<=l&&(s=l-1)}}function r(t,e,i,o){s(t,i,o),s(e,2*i,2*o),s(e,2*i+1,2*o+1)}function s(t,e,i){const o=t[e];t[e]=t[i],t[i]=o}function u(t,e,i,o){const n=t-i,r=e-o;return n*n+r*r}i.d(e,{Z:()=>f});const a=t=>t[0],c=t=>t[1];class l{constructor(t,e=a,i=c,n=64,r=Float64Array){this.nodeSize=n,this.points=t;const s=t.length<65536?Uint16Array:Uint32Array,u=this.ids=new s(t.length),l=this.coords=new r(2*t.length);for(let o=0;o<t.length;o++)u[o]=o,l[2*o]=e(t[o]),l[2*o+1]=i(t[o]);o(u,l,n,0,u.length-1,0)}range(t,e,i,o){return function(t,e,i,o,n,r,s){const u=[0,t.length-1,0],a=[];let c,l;for(;u.length;){const h=u.pop(),p=u.pop(),d=u.pop();if(p-d<=s){for(let s=d;s<=p;s++)c=e[2*s],l=e[2*s+1],c>=i&&c<=n&&l>=o&&l<=r&&a.push(t[s]);continue}const f=Math.floor((d+p)/2);c=e[2*f],l=e[2*f+1],c>=i&&c<=n&&l>=o&&l<=r&&a.push(t[f]);const g=(h+1)%2;(0===h?i<=c:o<=l)&&(u.push(d),u.push(f-1),u.push(g)),(0===h?n>=c:r>=l)&&(u.push(f+1),u.push(p),u.push(g))}return a}(this.ids,this.coords,t,e,i,o,this.nodeSize)}within(t,e,i){return function(t,e,i,o,n,r){const s=[0,t.length-1,0],a=[],c=n*n;for(;s.length;){const l=s.pop(),h=s.pop(),p=s.pop();if(h-p<=r){for(let n=p;n<=h;n++)u(e[2*n],e[2*n+1],i,o)<=c&&a.push(t[n]);continue}const d=Math.floor((p+h)/2),f=e[2*d],g=e[2*d+1];u(f,g,i,o)<=c&&a.push(t[d]);const m=(l+1)%2;(0===l?i-n<=f:o-n<=g)&&(s.push(p),s.push(d-1),s.push(m)),(0===l?i+n>=f:o+n>=g)&&(s.push(d+1),s.push(h),s.push(m))}return a}(this.ids,this.coords,t,e,i,this.nodeSize)}}const h={minZoom:0,maxZoom:16,minPoints:2,radius:40,extent:512,nodeSize:64,log:!1,generateId:!1,reduce:null,map:t=>t},p=Math.fround||(d=new Float32Array(1),t=>(d[0]=+t,d[0]));var d;class f{constructor(t){this.options=k(Object.create(h),t),this.trees=new Array(this.options.maxZoom+1)}load(t){const{log:e,minZoom:i,maxZoom:o,nodeSize:n}=this.options;e&&console.time("total time");const r=`prepare ${t.length} points`;e&&console.time(r),this.points=t;let s=[];for(let u=0;u<t.length;u++)t[u].geometry&&s.push(m(t[u],u));this.trees[o+1]=new l(s,C,A,n,Float32Array),e&&console.timeEnd(r);for(let u=o;u>=i;u--){const t=+Date.now();s=this._cluster(s,u),this.trees[u]=new l(s,C,A,n,Float32Array),e&&console.log("z%d: %d clusters in %dms",u,s.length,+Date.now()-t)}return e&&console.timeEnd("total time"),this}getClusters(t,e){let i=((t[0]+180)%360+360)%360-180;const o=Math.max(-90,Math.min(90,t[1]));let n=180===t[2]?180:((t[2]+180)%360+360)%360-180;const r=Math.max(-90,Math.min(90,t[3]));if(t[2]-t[0]>=360)i=-180,n=180;else if(i>n){const t=this.getClusters([i,o,180,r],e),s=this.getClusters([-180,o,n,r],e);return t.concat(s)}const s=this.trees[this._limitZoom(e)],u=s.range(y(i),_(r),y(n),_(o)),a=[];for(const c of u){const t=s.points[c];a.push(t.numPoints?v(t):this.points[t.index])}return a}getChildren(t){const e=this._getOriginId(t),i=this._getOriginZoom(t),o="No cluster with the specified id.",n=this.trees[i];if(!n)throw new Error(o);const r=n.points[e];if(!r)throw new Error(o);const s=this.options.radius/(this.options.extent*Math.pow(2,i-1)),u=n.within(r.x,r.y,s),a=[];for(const c of u){const e=n.points[c];e.parentId===t&&a.push(e.numPoints?v(e):this.points[e.index])}if(0===a.length)throw new Error(o);return a}getLeaves(t,e,i){e=e||10,i=i||0;const o=[];return this._appendLeaves(o,t,e,i,0),o}getTile(t,e,i){const o=this.trees[this._limitZoom(t)],n=Math.pow(2,t),{extent:r,radius:s}=this.options,u=s/r,a=(i-u)/n,c=(i+1+u)/n,l={features:[]};return this._addTileFeatures(o.range((e-u)/n,a,(e+1+u)/n,c),o.points,e,i,n,l),0===e&&this._addTileFeatures(o.range(1-u/n,a,1,c),o.points,n,i,n,l),e===n-1&&this._addTileFeatures(o.range(0,a,u/n,c),o.points,-1,i,n,l),l.features.length?l:null}getClusterExpansionZoom(t){let e=this._getOriginZoom(t)-1;for(;e<=this.options.maxZoom;){const i=this.getChildren(t);if(e++,1!==i.length)break;t=i[0].properties.cluster_id}return e}_appendLeaves(t,e,i,o,n){const r=this.getChildren(e);for(const s of r){const e=s.properties;if(e&&e.cluster?n+e.point_count<=o?n+=e.point_count:n=this._appendLeaves(t,e.cluster_id,i,o,n):n<o?n++:t.push(s),t.length===i)break}return n}_addTileFeatures(t,e,i,o,n,r){for(const s of t){const t=e[s],u=t.numPoints;let a,c,l;if(u)a=b(t),c=t.x,l=t.y;else{const e=this.points[t.index];a=e.properties,c=y(e.geometry.coordinates[0]),l=_(e.geometry.coordinates[1])}const h={type:1,geometry:[[Math.round(this.options.extent*(c*n-i)),Math.round(this.options.extent*(l*n-o))]],tags:a};let p;u?p=t.id:this.options.generateId?p=t.index:this.points[t.index].id&&(p=this.points[t.index].id),void 0!==p&&(h.id=p),r.features.push(h)}}_limitZoom(t){return Math.max(this.options.minZoom,Math.min(Math.floor(+t),this.options.maxZoom+1))}_cluster(t,e){const i=[],{radius:o,extent:n,reduce:r,minPoints:s}=this.options,u=o/(n*Math.pow(2,e));for(let a=0;a<t.length;a++){const o=t[a];if(o.zoom<=e)continue;o.zoom=e;const n=this.trees[e+1],c=n.within(o.x,o.y,u),l=o.numPoints||1;let h=l;for(const t of c){const i=n.points[t];i.zoom>e&&(h+=i.numPoints||1)}if(h>l&&h>=s){let t=o.x*l,s=o.y*l,u=r&&l>1?this._map(o,!0):null;const p=(a<<5)+(e+1)+this.points.length;for(const i of c){const a=n.points[i];if(a.zoom<=e)continue;a.zoom=e;const c=a.numPoints||1;t+=a.x*c,s+=a.y*c,a.parentId=p,r&&(u||(u=this._map(o,!0)),r(u,this._map(a)))}o.parentId=p,i.push(g(t/h,s/h,p,h,u))}else if(i.push(o),h>1)for(const t of c){const o=n.points[t];o.zoom<=e||(o.zoom=e,i.push(o))}}return i}_getOriginId(t){return t-this.points.length>>5}_getOriginZoom(t){return(t-this.points.length)%32}_map(t,e){if(t.numPoints)return e?k({},t.properties):t.properties;const i=this.points[t.index].properties,o=this.options.map(i);return e&&o===i?k({},o):o}}function g(t,e,i,o,n){return{x:p(t),y:p(e),zoom:1/0,id:i,parentId:-1,numPoints:o,properties:n}}function m(t,e){const[i,o]=t.geometry.coordinates;return{x:p(y(i)),y:p(_(o)),zoom:1/0,index:e,parentId:-1}}function v(t){return{type:"Feature",id:t.id,properties:b(t),geometry:{type:"Point",coordinates:[(e=t.x,360*(e-.5)),x(t.y)]}};var e}function b(t){const e=t.numPoints,i=e>=1e4?`${Math.round(e/1e3)}k`:e>=1e3?Math.round(e/100)/10+"k":e;return k(k({},t.properties),{cluster:!0,cluster_id:t.id,point_count:e,point_count_abbreviated:i})}function y(t){return t/360+.5}function _(t){const e=Math.sin(t*Math.PI/180),i=.5-.25*Math.log((1+e)/(1-e))/Math.PI;return i<0?0:i>1?1:i}function x(t){const e=(180-360*t)*Math.PI/180;return 360*Math.atan(Math.exp(e))/Math.PI-90}function k(t,e){for(const i in e)t[i]=e[i];return t}function C(t){return t.x}function A(t){return t.y}},41708:(t,e,i)=>{i.d(e,{Z:()=>r});var o=i(41199),n=i(53563);class r{constructor(t){this.id=void 0,this.topology=void 0,this.vertexCount=void 0,this.indices=void 0,this.attributes=void 0,this.userData={};const{attributes:e={},indices:i=null,vertexCount:r=null}=t;this.id=t.id||(0,o.hQ)("geometry"),this.topology=t.topology,i&&(this.indices=ArrayBuffer.isView(i)?{value:i,size:1}:i),this.attributes={};for(const[o,s]of Object.entries(e)){const t=ArrayBuffer.isView(s)?{value:s}:s;(0,n.h)(ArrayBuffer.isView(t.value),`${this._print(o)}: must be typed array or object with value as typed array`),"POSITION"!==o&&"positions"!==o||t.size||(t.size=3),"indices"===o?((0,n.h)(!this.indices),this.indices=t):this.attributes[o]=t}this.indices&&void 0!==this.indices.isIndexed&&(this.indices=Object.assign({},this.indices),delete this.indices.isIndexed),this.vertexCount=r||this._calculateVertexCount(this.attributes,this.indices)}getVertexCount(){return this.vertexCount}getAttributes(){return this.indices?{indices:this.indices,...this.attributes}:this.attributes}_print(t){return`Geometry ${this.id} attribute ${t}`}_setAttributes(t,e){return this}_calculateVertexCount(t,e){if(e)return e.value.length;let i=1/0;for(const o of Object.values(t)){const{value:t,size:e,constant:n}=o;!n&&t&&e>=1&&(i=Math.min(i,t.length/e))}return(0,n.h)(Number.isFinite(i)),i}}},70138:(t,e,i)=>{i.d(e,{H:()=>f});var o=i(41199);function n(t,e,i){if(t===e)return!0;if(!i||!t||!e)return!1;if(Array.isArray(t)){if(!Array.isArray(e)||t.length!==e.length)return!1;for(let o=0;o<t.length;o++)if(!n(t[o],e[o],i-1))return!1;return!0}if(Array.isArray(e))return!1;if("object"==typeof t&&"object"==typeof e){const o=Object.keys(t),r=Object.keys(e);if(o.length!==r.length)return!1;for(const s of o){if(!e.hasOwnProperty(s))return!1;if(!n(t[s],e[s],i-1))return!1}return!0}return!1}var r=i(47407),s=i(34210),u=i(55866),a=i(65352),c=i(53563),l=i(63847);class h{constructor(t){this.id=void 0,this.userData={},this.topology=void 0,this.bufferLayout=[],this.vertexCount=void 0,this.indices=void 0,this.attributes=void 0,this.id=t.id||(0,o.hQ)("geometry"),this.topology=t.topology,this.indices=t.indices||null,this.attributes=t.attributes,this.vertexCount=t.vertexCount,this.bufferLayout=t.bufferLayout||[],this.indices&&(0,c.h)(this.indices.usage===l.l.INDEX)}destroy(){var t;this.indices.destroy(),this.attributes.positions.destroy(),this.attributes.normals.destroy(),this.attributes.texCoords.destroy(),null===(t=this.attributes.colors)||void 0===t||t.destroy()}getVertexCount(){return this.vertexCount}getAttributes(){return this.attributes}getIndexes(){return this.indices}_calculateVertexCount(t){return t.byteLength/12}}function p(t,e){if(e instanceof h)return e;const i=function(t,e){if(!e.indices)return;const i=e.indices.value;return t.createBuffer({usage:l.l.INDEX,data:i})}(t,e),{attributes:o,bufferLayout:n}=function(t,e){const i=[],o={};for(const[r,s]of Object.entries(e.attributes)){let e=r;switch(r){case"POSITION":e="positions";break;case"NORMAL":e="normals";break;case"TEXCOORD_0":e="texCoords"}o[e]=t.createBuffer({data:s.value,id:`${r}-buffer`}),i.push({name:e,format:`float32x${s.size}`})}const n=e._calculateVertexCount(e.attributes,e.indices);return{attributes:o,bufferLayout:i,vertexCount:n}}(t,e);return new h({topology:e.topology||"triangle-list",bufferLayout:n,vertexCount:e.vertexCount,indices:i,attributes:o})}var d=i(38908);class f{constructor(t,e){this.device=void 0,this.id=void 0,this.vs=void 0,this.fs=void 0,this.pipelineFactory=void 0,this.userData={},this.parameters=void 0,this.topology=void 0,this.bufferLayout=void 0,this.vertexCount=void 0,this.instanceCount=0,this.indexBuffer=null,this.bufferAttributes={},this.constantAttributes={},this.bindings={},this.uniforms={},this.pipeline=void 0,this.vertexArray=void 0,this._pipelineNeedsUpdate="newly created",this._attributeInfos={},this._gpuGeometry=null,this._getModuleUniforms=void 0,this.props=void 0,this.props={...f.defaultProps,...e},e=this.props,this.id=e.id||(0,o.hQ)("model"),this.device=t,Object.assign(this.userData,e.userData);const i={type:t.info.type,shaderLanguage:t.info.shadingLanguages[0],gpu:t.info.gpu,features:t.features},{vs:n,fs:r,getUniforms:s}=this.props.shaderAssembler.assembleShaders(i,this.props);if(this.vs=n,this.fs=r,this._getModuleUniforms=s,this.vertexCount=this.props.vertexCount,this.instanceCount=this.props.instanceCount,this.topology=this.props.topology,this.bufferLayout=this.props.bufferLayout,this.parameters=this.props.parameters,e.geometry&&(this._gpuGeometry=this.setGeometry(e.geometry)),this.pipelineFactory=e.pipelineFactory||d.g.getDefaultPipelineFactory(this.device),this.pipeline=this._updatePipeline(),this.vertexArray=t.createVertexArray({renderPipeline:this.pipeline}),this._gpuGeometry&&this._setGeometryAttributes(this._gpuGeometry),e.vertexCount&&this.setVertexCount(e.vertexCount),e.instanceCount&&this.setInstanceCount(e.instanceCount),e.indices)throw new Error("Model.props.indices removed. Use props.indexBuffer");e.indexBuffer&&this.setIndexBuffer(e.indexBuffer),e.attributes&&this.setAttributes(e.attributes),e.constantAttributes&&this.setConstantAttributes(e.constantAttributes),e.bindings&&this.setBindings(e.bindings),e.uniforms&&this.setUniforms(e.uniforms),e.moduleSettings&&this.updateModuleSettings(e.moduleSettings),this.setUniforms(this._getModuleUniforms()),Object.seal(this)}destroy(){this.pipelineFactory.release(this.pipeline)}draw(t){this.pipeline=this._updatePipeline(),this.pipeline.setBindings(this.bindings),this.pipeline.setUniforms(this.uniforms),this.pipeline.draw({renderPass:t,vertexArray:this.vertexArray,vertexCount:this.vertexCount,instanceCount:this.instanceCount})}setGeometry(t){const e=t&&p(this.device,t);return this.setTopology(e.topology||"triangle-list"),this.bufferLayout=g(this.bufferLayout,e.bufferLayout),this.vertexArray&&this._setGeometryAttributes(e),e}_setGeometryAttributes(t){this.vertexCount=t.vertexCount,this.setAttributes(t.attributes),this.setIndexBuffer(t.indices)}setTopology(t){t!==this.topology&&(this.topology=t,this._setPipelineNeedsUpdate("topology"))}setBufferLayout(t){this.bufferLayout=this._gpuGeometry?g(t,this._gpuGeometry.bufferLayout):t,this._setPipelineNeedsUpdate("bufferLayout"),this.pipeline=this._updatePipeline(),this.vertexArray=this.device.createVertexArray({renderPipeline:this.pipeline}),this._gpuGeometry&&this._setGeometryAttributes(this._gpuGeometry)}setParameters(t){n(t,this.parameters,2)||(this.parameters=t,this._setPipelineNeedsUpdate("parameters"))}setVertexCount(t){this.vertexCount=t}setInstanceCount(t){this.instanceCount=t}setShaderModuleProps(t){const e=this._getModuleUniforms(t),i=Object.keys(e).filter((t=>{const i=e[t];return!Array.isArray(i)&&"number"!=typeof i&&"boolean"!=typeof i})),o={};for(const n of i)o[n]=e[n],delete e[n];Object.assign(this.uniforms,e),Object.assign(this.bindings,o)}updateModuleSettings(t){this.setShaderModuleProps(t)}setBindings(t){Object.assign(this.bindings,t)}setUniforms(t){this.pipeline.setUniforms(t),Object.assign(this.uniforms,t)}setIndexBuffer(t){this.vertexArray.setIndexBuffer(t)}setAttributes(t){t.indices&&r.c.warn(`Model:${this.id} setAttributes() - indexBuffer should be set using setIndexBuffer()`);for(const[i,o]of Object.entries(t)){var e;const t=this.bufferLayout.find((t=>t.name===i));if(!t)continue;const n=t.attributes?null===(e=t.attributes)||void 0===e?void 0:e.map((t=>t.attribute)):[t.name];let s=!1;for(const e of n){const t=this._attributeInfos[e];t&&(this.vertexArray.setBuffer(t.location,o),s=!0)}s||r.c.warn(`Model(${this.id}): Ignoring buffer "${o.id}" for unknown attribute "${i}"`)()}}setConstantAttributes(t){for(const[e,i]of Object.entries(t)){const t=this._attributeInfos[e];t?this.vertexArray.setConstant(t.location,i):r.c.warn(`Model "${this.id}: Ignoring constant supplied for unknown attribute "${e}"`)()}}_setPipelineNeedsUpdate(t){this._pipelineNeedsUpdate=this._pipelineNeedsUpdate||t}_updatePipeline(){return this._pipelineNeedsUpdate&&(this.pipeline&&r.c.log(1,`Model ${this.id}: Recreating pipeline because "${this._pipelineNeedsUpdate}".`)(),this._pipelineNeedsUpdate=!1,this.pipeline=this.device.createRenderPipeline({...this.props,bufferLayout:this.bufferLayout,topology:this.topology,parameters:this.parameters,vs:this.device.createShader({id:"{$this.id}-vertex",stage:"vertex",source:this.vs}),fs:this.fs?this.device.createShader({id:"{$this.id}-fragment",stage:"fragment",source:this.fs}):null}),this._attributeInfos=(0,u.G5)(this.pipeline.shaderLayout,this.bufferLayout)),this.pipeline}}function g(t,e){const i=[...t];for(const o of e){const t=i.findIndex((t=>t.name===o.name));t<0?i.push(o):i[t]=o}return i}f.defaultProps={...s.h.defaultProps,vs:null,fs:null,id:"unnamed",handle:void 0,userData:{},defines:{},modules:[],moduleSettings:{},geometry:null,indexBuffer:null,attributes:{},constantAttributes:{},pipelineFactory:void 0,shaderAssembler:a.q.getDefaultShaderAssembler()}},7206:(t,e,i)=>{i.d(e,{q:()=>r});var o=i(27872);const n={pickingActive:!1,pickingAttribute:!1,pickingSelectedColor:null,pickingHighlightColor:new Uint8Array([0,255,255,255]),pickingColorRange:255};const r={name:"picking",vs:o.H`\
uniform bool picking_uActive;
uniform bool picking_uAttribute;
uniform vec3 picking_uSelectedColor;
uniform bool picking_uSelectedColorValid;
uniform float picking_uColorScale;

out vec4 picking_vRGBcolor_Avalid;

bool picking_isColorValid(vec3 color) {
  return dot(color, vec3(1.0)) > 0.001;
}

bool isVertexPicked(vec3 vertexColor) {
  return
    picking_uSelectedColorValid &&
    !picking_isColorValid(abs(vertexColor - picking_uSelectedColor));
}

void picking_setPickingColor(vec3 pickingColor) {
  if (picking_uActive) {
    // Use alpha as the validity flag. If pickingColor is [0, 0, 0] fragment is non-pickable
    picking_vRGBcolor_Avalid.a = float(picking_isColorValid(pickingColor));

    // if (!picking_uAttribute) {
      // Stores the picking color so that the fragment shader can render it during picking
      picking_vRGBcolor_Avalid.rgb = pickingColor * picking_uColorScale;
    // }
  } else {
    // Do the comparison with selected item color in vertex shader as it should mean fewer compares
    picking_vRGBcolor_Avalid.a = float(isVertexPicked(pickingColor));
  }
}

void picking_setPickingAttribute(float value) {
  if (picking_uAttribute) {
    picking_vRGBcolor_Avalid.r = value;
  }
}
void picking_setPickingAttribute(vec2 value) {
  if (picking_uAttribute) {
    picking_vRGBcolor_Avalid.rg = value;
  }
}
void picking_setPickingAttribute(vec3 value) {
  if (picking_uAttribute) {
    picking_vRGBcolor_Avalid.rgb = value;
  }
}
`,fs:o.H`\
uniform bool picking_uActive;
uniform vec3 picking_uSelectedColor;
uniform vec4 picking_uHighlightColor;

in vec4 picking_vRGBcolor_Avalid;

/*
 * Returns highlight color if this item is selected.
 */
vec4 picking_filterHighlightColor(vec4 color) {
  if (picking_uActive) {
    return color;
  }
  bool selected = bool(picking_vRGBcolor_Avalid.a);

  if (selected) {
    float highLightAlpha = picking_uHighlightColor.a;
    float blendedAlpha = highLightAlpha + color.a * (1.0 - highLightAlpha);
    float highLightRatio = highLightAlpha / blendedAlpha;

    vec3 blendedRGB = mix(color.rgb, picking_uHighlightColor.rgb, highLightRatio);
    return vec4(blendedRGB, blendedAlpha);
  } else {
    return color;
  }
}

/*
 * Returns picking color if picking enabled else unmodified argument.
 */
vec4 picking_filterPickingColor(vec4 color) {
  if (picking_uActive) {
    if (picking_vRGBcolor_Avalid.a == 0.0) {
      discard;
    }
    return picking_vRGBcolor_Avalid;
  }
  return color;
}

/*
 * Returns picking color if picking is enabled if not
 * highlight color if this item is selected, otherwise unmodified argument.
 */
vec4 picking_filterColor(vec4 color) {
  vec4 highightColor = picking_filterHighlightColor(color);
  return picking_filterPickingColor(highightColor);
}

`,getUniforms:function(){let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:n;const e={};if(void 0!==t.pickingActive&&(e.picking_uActive=Boolean(t.pickingActive),e.picking_uAttribute=Boolean(t.pickingAttribute)),void 0!==t.pickingSelectedColor)if(t.pickingSelectedColor){const i=t.pickingSelectedColor.slice(0,3);e.picking_uSelectedColorValid=1,e.picking_uSelectedColor=i}else e.picking_uSelectedColorValid=0;if(t.pickingHighlightColor){const i=Array.from(t.pickingHighlightColor,(t=>t/255));Number.isFinite(i[3])||(i[3]=1),e.picking_uHighlightColor=i}return t.pickingColorRange&&(e.picking_uColorScale=1/t.pickingColorRange),e}}}}]);