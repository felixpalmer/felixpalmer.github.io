"use strict";(self.webpackChunkproject_website=self.webpackChunkproject_website||[]).push([[3923],{35983:(i,t,n)=>{function e(i){let t=1/0,n=1/0,e=1/0,o=-1/0,r=-1/0,l=-1/0;const a=i.POSITION?i.POSITION.value:[],c=a&&a.length;for(let s=0;s<c;s+=3){const i=a[s],c=a[s+1],h=a[s+2];t=i<t?i:t,n=c<n?c:n,e=h<e?h:e,o=i>o?i:o,r=c>r?c:r,l=h>l?h:l}return[[t,n,e],[o,r,l]]}n.d(t,{l:()=>e})},72404:(i,t,n)=>{n.d(t,{w:()=>r});var e=n(10513);var o=n(38846);const r={name:"phongMaterial",dependencies:[e.x],source:"struct phongMaterialUniforms {\n  ambient: f32,\n  diffuse: f32,\n  shininess: f32,\n  specularColor: vec3<f32>,\n};\n\n@binding(2) @group(0) var<uniform> material : phongMaterialUniforms;\n\nfn lighting_getLightColor(surfaceColor: vec3<f32>, light_direction: vec3<f32>, view_direction: vec3<f32>, normal_worldspace: vec3<f32>, color: vec3<f32>) -> vec3<f32> {\n  let halfway_direction: vec3<f32> = normalize(light_direction + view_direction);\n  var lambertian: f32 = dot(light_direction, normal_worldspace);\n  var specular: f32 = 0.0;\n  if (lambertian > 0.0) {\n    let specular_angle = max(dot(normal_worldspace, halfway_direction), 0.0);\n    specular = pow(specular_angle, material.shininess);\n  }\n  lambertian = max(lambertian, 0.0);\n  return (lambertian * material.diffuse * surfaceColor + specular * material.specularColor) * color;\n}\n\nfn lighting_getLightColor2(surfaceColor: vec3<f32>, cameraPosition: vec3<f32>, position_worldspace: vec3<f32>, normal_worldspace: vec3<f32>) -> vec3<f32> {\n  var lightColor: vec3<f32> = surfaceColor;\n\n  if (lighting.enabled == 0) {\n    return lightColor;\n  }\n\n  let view_direction: vec3<f32> = normalize(cameraPosition - position_worldspace);\n  lightColor = material.ambient * surfaceColor * lighting.ambientColor;\n\n  if (lighting.lightType == 0) {\n    let pointLight: PointLight  = lighting_getPointLight(0);\n    let light_position_worldspace: vec3<f32> = pointLight.position;\n    let light_direction: vec3<f32> = normalize(light_position_worldspace - position_worldspace);\n    lightColor += lighting_getLightColor(surfaceColor, light_direction, view_direction, normal_worldspace, pointLight.color);\n  } else if (lighting.lightType == 1) {\n    var directionalLight: DirectionalLight = lighting_getDirectionalLight(0);\n    lightColor += lighting_getLightColor(surfaceColor, -directionalLight.direction, view_direction, normal_worldspace, directionalLight.color);\n  }\n  \n  return lightColor;\n  /*\n  for (int i = 0; i < MAX_LIGHTS; i++) {\n    if (i >= lighting.pointLightCount) {\n      break;\n    }\n    PointLight pointLight = lighting.pointLight[i];\n    vec3 light_position_worldspace = pointLight.position;\n    vec3 light_direction = normalize(light_position_worldspace - position_worldspace);\n    lightColor += lighting_getLightColor(surfaceColor, light_direction, view_direction, normal_worldspace, pointLight.color);\n  }\n\n  for (int i = 0; i < MAX_LIGHTS; i++) {\n    if (i >= lighting.directionalLightCount) {\n      break;\n    }\n    DirectionalLight directionalLight = lighting.directionalLight[i];\n    lightColor += lighting_getLightColor(surfaceColor, -directionalLight.direction, view_direction, normal_worldspace, directionalLight.color);\n  }\n  */\n}\n\nfn lighting_getSpecularLightColor(cameraPosition: vec3<f32>, position_worldspace: vec3<f32>, normal_worldspace: vec3<f32>) -> vec3<f32>{\n  var lightColor = vec3<f32>(0, 0, 0);\n  let surfaceColor = vec3<f32>(0, 0, 0);\n\n  if (lighting.enabled == 0) {\n    let view_direction = normalize(cameraPosition - position_worldspace);\n\n    switch (lighting.lightType) {\n      case 0, default: {\n        let pointLight: PointLight = lighting_getPointLight(0);\n        let light_position_worldspace: vec3<f32> = pointLight.position;\n        let light_direction: vec3<f32> = normalize(light_position_worldspace - position_worldspace);\n        lightColor += lighting_getLightColor(surfaceColor, light_direction, view_direction, normal_worldspace, pointLight.color);\n      }\n      case 1: {\n        let directionalLight: DirectionalLight = lighting_getDirectionalLight(0);\n        lightColor += lighting_getLightColor(surfaceColor, -directionalLight.direction, view_direction, normal_worldspace, directionalLight.color);\n      }\n    }\n  }\n  return lightColor;\n}\n",vs:o.X,fs:o.l,defines:{LIGHTING_FRAGMENT:1},uniformTypes:{ambient:"f32",diffuse:"f32",shininess:"f32",specularColor:"vec3<f32>"},defaultUniforms:{ambient:.35,diffuse:.6,shininess:32,specularColor:[.15,.15,.15]},getUniforms(i){const t={...i};return t.specularColor&&(t.specularColor=t.specularColor.map((i=>i/255))),{...r.defaultUniforms,...t}}}},75228:(i,t,n)=>{n.d(t,{A:()=>o});const e=1e20;class o{constructor({fontSize:i=24,buffer:t=3,radius:n=8,cutoff:e=.25,fontFamily:o="sans-serif",fontWeight:r="normal",fontStyle:l="normal"}={}){this.buffer=t,this.cutoff=e,this.radius=n;const a=this.size=i+4*t,c=this._createCanvas(a),s=this.ctx=c.getContext("2d",{willReadFrequently:!0});s.font=`${l} ${r} ${i}px ${o}`,s.textBaseline="alphabetic",s.textAlign="left",s.fillStyle="black",this.gridOuter=new Float64Array(a*a),this.gridInner=new Float64Array(a*a),this.f=new Float64Array(a),this.z=new Float64Array(a+1),this.v=new Uint16Array(a)}_createCanvas(i){const t=document.createElement("canvas");return t.width=t.height=i,t}draw(i){const{width:t,actualBoundingBoxAscent:n,actualBoundingBoxDescent:o,actualBoundingBoxLeft:l,actualBoundingBoxRight:a}=this.ctx.measureText(i),c=Math.ceil(n),s=Math.max(0,Math.min(this.size-this.buffer,Math.ceil(a-l))),h=Math.min(this.size-this.buffer,c+Math.ceil(o)),f=s+2*this.buffer,g=h+2*this.buffer,u=Math.max(f*g,0),d=new Uint8ClampedArray(u),p={data:d,width:f,height:g,glyphWidth:s,glyphHeight:h,glyphTop:c,glyphLeft:0,glyphAdvance:t};if(0===s||0===h)return p;const{ctx:m,buffer:v,gridInner:_,gridOuter:w}=this;m.clearRect(v,v,s,h),m.fillText(i,v,v+c);const C=m.getImageData(v,v,s,h);w.fill(e,0,u),_.fill(0,0,u);for(let r=0;r<h;r++)for(let i=0;i<s;i++){const t=C.data[4*(r*s+i)+3]/255;if(0===t)continue;const n=(r+v)*f+i+v;if(1===t)w[n]=0,_[n]=e;else{const i=.5-t;w[n]=i>0?i*i:0,_[n]=i<0?i*i:0}}r(w,0,0,f,g,f,this.f,this.v,this.z),r(_,v,v,s,h,f,this.f,this.v,this.z);for(let e=0;e<u;e++){const i=Math.sqrt(w[e])-Math.sqrt(_[e]);d[e]=Math.round(255-255*(i/this.radius+this.cutoff))}return p}}function r(i,t,n,e,o,r,a,c,s){for(let h=t;h<t+e;h++)l(i,n*r+h,r,o,a,c,s);for(let h=n;h<n+o;h++)l(i,h*r+t,1,e,a,c,s)}function l(i,t,n,o,r,l,a){l[0]=0,a[0]=-e,a[1]=e,r[0]=i[t];for(let c=1,s=0,h=0;c<o;c++){r[c]=i[t+c*n];const o=c*c;do{const i=l[s];h=(r[c]-r[i]+o-i*i)/(c-i)/2}while(h<=a[s]&&--s>-1);s++,l[s]=c,a[s]=h,a[s+1]=e}for(let e=0,c=0;e<o;e++){for(;a[c+1]<e;)c++;const o=l[c],s=e-o;i[t+e*n]=r[o]+s*s}}},28453:(i,t,n)=>{n.d(t,{R:()=>l,x:()=>a});var e=n(96540);const o={},r=e.createContext(o);function l(i){const t=e.useContext(r);return e.useMemo((function(){return"function"==typeof i?i(t):{...t,...i}}),[t,i])}function a(i){let t;return t=i.disableParentContext?"function"==typeof i.components?i.components(o):i.components||o:l(i.components),e.createElement(r.Provider,{value:t},i.children)}},4504:(i,t,n)=>{function e(i,t){let n,e=-1,o=-1;if(void 0===t)for(const r of i)++o,null!=r&&(n<r||void 0===n&&r>=r)&&(n=r,e=o);else for(let r of i)null!=(r=t(r,++o,i))&&(n<r||void 0===n&&r>=r)&&(n=r,e=o);return e}n.d(t,{A:()=>e})},98026:(i,t,n)=>{function e(i,t){let n,e=-1,o=-1;if(void 0===t)for(const r of i)++o,null!=r&&(n>r||void 0===n&&r>=r)&&(n=r,e=o);else for(let r of i)null!=(r=t(r,++o,i))&&(n>r||void 0===n&&r>=r)&&(n=r,e=o);return e}n.d(t,{A:()=>e})},92269:(i,t,n)=>{n.d(t,{A:()=>f,C:()=>h});var e=n(6946),o=n(3081),r=n(99065),l=n(1631),a=n(47235);var c=n(2199);function s(i,t,n,o){var r,s=(0,e.sG)(i,t,n);switch((o=(0,l.A)(null==o?",f":o)).type){case"s":var h=Math.max(Math.abs(i),Math.abs(t));return null!=o.precision||isNaN(r=function(i,t){return Math.max(0,3*Math.max(-8,Math.min(8,Math.floor((0,a.A)(t)/3)))-(0,a.A)(Math.abs(i)))}(s,h))||(o.precision=r),(0,c.s)(o,h);case"":case"e":case"g":case"p":case"r":null!=o.precision||isNaN(r=function(i,t){return i=Math.abs(i),t=Math.abs(t)-i,Math.max(0,(0,a.A)(t)-(0,a.A)(i))+1}(s,Math.max(Math.abs(i),Math.abs(t))))||(o.precision=r-("e"===o.type));break;case"f":case"%":null!=o.precision||isNaN(r=function(i){return Math.max(0,-(0,a.A)(Math.abs(i)))}(s))||(o.precision=r-2*("%"===o.type))}return(0,c.GP)(o)}function h(i){var t=i.domain;return i.ticks=function(i){var n=t();return(0,e.Ay)(n[0],n[n.length-1],null==i?10:i)},i.tickFormat=function(i,n){var e=t();return s(e[0],e[e.length-1],null==i?10:i,n)},i.nice=function(n){null==n&&(n=10);var o,r,l=t(),a=0,c=l.length-1,s=l[a],h=l[c],f=10;for(h<s&&(r=s,s=h,h=r,r=a,a=c,c=r);f-- >0;){if((r=(0,e.lq)(s,h,n))===o)return l[a]=s,l[c]=h,t(l);if(r>0)s=Math.floor(s/r)*r,h=Math.ceil(h/r)*r;else{if(!(r<0))break;s=Math.ceil(s*r)/r,h=Math.floor(h*r)/r}o=r}return i},i}function f(){var i=(0,o.Ay)();return i.copy=function(){return(0,o.C)(i,f())},r.C.apply(i,arguments),h(i)}}}]);