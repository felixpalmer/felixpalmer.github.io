"use strict";(self.webpackChunkproject_website=self.webpackChunkproject_website||[]).push([[5259],{3905:(e,t,r)=>{r.d(t,{Zo:()=>c,kt:()=>m});var n=r(67294);function a(e,t,r){return t in e?Object.defineProperty(e,t,{value:r,enumerable:!0,configurable:!0,writable:!0}):e[t]=r,e}function i(e,t){var r=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),r.push.apply(r,n)}return r}function o(e){for(var t=1;t<arguments.length;t++){var r=null!=arguments[t]?arguments[t]:{};t%2?i(Object(r),!0).forEach((function(t){a(e,t,r[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(r)):i(Object(r)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(r,t))}))}return e}function l(e,t){if(null==e)return{};var r,n,a=function(e,t){if(null==e)return{};var r,n,a={},i=Object.keys(e);for(n=0;n<i.length;n++)r=i[n],t.indexOf(r)>=0||(a[r]=e[r]);return a}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(n=0;n<i.length;n++)r=i[n],t.indexOf(r)>=0||Object.prototype.propertyIsEnumerable.call(e,r)&&(a[r]=e[r])}return a}var s=n.createContext({}),d=function(e){var t=n.useContext(s),r=t;return e&&(r="function"==typeof e?e(t):o(o({},t),e)),r},c=function(e){var t=d(e.components);return n.createElement(s.Provider,{value:t},e.children)},u="mdxType",p={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},h=n.forwardRef((function(e,t){var r=e.components,a=e.mdxType,i=e.originalType,s=e.parentName,c=l(e,["components","mdxType","originalType","parentName"]),u=d(r),h=a,m=u["".concat(s,".").concat(h)]||u[h]||p[h]||i;return r?n.createElement(m,o(o({ref:t},c),{},{components:r})):n.createElement(m,o({ref:t},c))}));function m(e,t){var r=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var i=r.length,o=new Array(i);o[0]=h;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l[u]="string"==typeof e?e:a,o[1]=l;for(var d=2;d<i;d++)o[d]=r[d];return n.createElement.apply(null,o)}return n.createElement.apply(null,r)}h.displayName="MDXCreateElement"},32409:(e,t,r)=>{r.r(t),r.d(t,{assets:()=>s,contentTitle:()=>o,default:()=>p,frontMatter:()=>i,metadata:()=>l,toc:()=>d});var n=r(87462),a=(r(67294),r(3905));const i={},o="Writing Shaders",l={unversionedId:"developer-guide/custom-layers/writing-shaders",id:"developer-guide/custom-layers/writing-shaders",title:"Writing Shaders",description:"A shader library facilitates creating shaders that work seamlessly with deck.gl. The modules parameter passed to the Model class can dynamically include parts from this library into your own GLSL code:",source:"@site/../docs/developer-guide/custom-layers/writing-shaders.md",sourceDirName:"developer-guide/custom-layers",slug:"/developer-guide/custom-layers/writing-shaders",permalink:"/deck.gl/docs/developer-guide/custom-layers/writing-shaders",draft:!1,editUrl:"https://github.com/visgl/deck.gl/tree/master/website/../docs/developer-guide/custom-layers/writing-shaders.md",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Attribute Management",permalink:"/deck.gl/docs/developer-guide/custom-layers/attribute-management"},next:{title:"Using with ArcGIS",permalink:"/deck.gl/docs/developer-guide/base-maps/using-with-arcgis"}},s={},d=[{value:"Shader Assembly",id:"shader-assembly",level:2},{value:"Platform defines",id:"platform-defines",level:3},{value:"Shader Modules",id:"shader-modules",level:3},{value:"projection",id:"projection",level:4},{value:"lighting",id:"lighting",level:4},{value:"fp64",id:"fp64",level:4},{value:"picking",id:"picking",level:4},{value:"Standard Shader Hooks",id:"standard-shader-hooks",level:3},{value:"vs:#decl",id:"vsdecl",level:5},{value:"vs:#main-start",id:"vsmain-start",level:5},{value:"vs:#main-end",id:"vsmain-end",level:5},{value:"vs:DECKGL_FILTER_SIZE",id:"vsdeckgl_filter_size",level:5},{value:"vs:DECKGL_FILTER_GL_POSITION",id:"vsdeckgl_filter_gl_position",level:5},{value:"vs:DECKGL_FILTER_COLOR",id:"vsdeckgl_filter_color",level:5},{value:"fs:#decl",id:"fsdecl",level:5},{value:"fs:#main-start",id:"fsmain-start",level:5},{value:"fs:#main-end",id:"fsmain-end",level:5},{value:"fs:DECKGL_FILTER_COLOR",id:"fsdeckgl_filter_color",level:5},{value:"VertexGeometry struct",id:"vertexgeometry-struct",level:3},{value:"FragmentGeometry struct",id:"fragmentgeometry-struct",level:3},{value:"Shader Techniques and Ideas",id:"shader-techniques-and-ideas",level:2},{value:"Filtering and Brushing (Vertex and Fragment Shaders)",id:"filtering-and-brushing-vertex-and-fragment-shaders",level:3},{value:"Animation (Vertex Shader)",id:"animation-vertex-shader",level:3},{value:"Uniforms",id:"uniforms",level:2},{value:"Layer prop uniforms",id:"layer-prop-uniforms",level:3},{value:"<code>float layerIndex</code>",id:"float",level:5},{value:"<code>float opacity</code>",id:"float",level:5},{value:"Shader Module Uniforms",id:"shader-module-uniforms",level:3},{value:"Remarks",id:"remarks",level:2}],c={toc:d},u="wrapper";function p(e){let{components:t,...r}=e;return(0,a.kt)(u,(0,n.Z)({},c,r,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("h1",{id:"writing-shaders"},"Writing Shaders"),(0,a.kt)("p",null,"A shader library facilitates creating shaders that work seamlessly with deck.gl. The ",(0,a.kt)("inlineCode",{parentName:"p"},"modules")," parameter passed to the ",(0,a.kt)("a",{parentName:"p",href:"https://github.com/visgl/luma.gl/blob/8.0-release/docs/api-reference/engine/model.md"},"Model")," class can dynamically include parts from this library into your own GLSL code:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-js"},"import {picking, project32, gouraudLighting} from '@deck.gl/core';\n\nconst model = new Model(gl, {\n  vs: '// vertex shader GLSL source'\n  fs: '// fragment shader GLSL source',\n  modules: [picking, project32, gouraudLighting] // list of optional module names\n});\n")),(0,a.kt)("h2",{id:"shader-assembly"},"Shader Assembly"),(0,a.kt)("p",null,"Your shaders will be run through the luma.gl ",(0,a.kt)("a",{parentName:"p",href:"https://github.com/visgl/luma.gl/blob/8.0-release/docs/api-reference/shadertools/assemble-shaders.md"},"shader assembler"),", which injects code from various module dependencies, The generated shader always contains a prologue of platform defines, and then the modules (see below), and finally your shader code is added."),(0,a.kt)("h3",{id:"platform-defines"},"Platform defines"),(0,a.kt)("p",null,'This "virtual" module is a dynamically generated prologue containing #defines describing your graphics card and platform. It is designed to work around certain platform-specific issues to allow the same rendering results are different GPUs and platforms. It is automatically injected by ',(0,a.kt)("inlineCode",{parentName:"p"},"assembleShaders")," before any modules are included."),(0,a.kt)("h3",{id:"shader-modules"},"Shader Modules"),(0,a.kt)("h4",{id:"projection"},"projection"),(0,a.kt)("p",null,"The ",(0,a.kt)("a",{parentName:"p",href:"/deck.gl/docs/api-reference/core/project"},"project")," shader module is part of the core of deck.gl. It makes it easy to write shaders that support all of deck.gl's projection modes and it supports some advanced rendering techniques such as pixel space rendering etc."),(0,a.kt)("p",null,"The ",(0,a.kt)("inlineCode",{parentName:"p"},"project")," module also has two extensions, ",(0,a.kt)("a",{parentName:"p",href:"/deck.gl/docs/api-reference/core/project32"},"project32")," and ",(0,a.kt)("a",{parentName:"p",href:"/deck.gl/docs/api-reference/core/project64"},"project64"),"."),(0,a.kt)("h4",{id:"lighting"},"lighting"),(0,a.kt)("p",null,"A simple lighting package is provided in deck.gl, supporting a single directional light in addition to ambient light. Turning on lighting requires normals to be provided for each vertex. There are two flavors:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"[gouraudLighting]"," - for lighting calculated in the vertex shader"),(0,a.kt)("li",{parentName:"ul"},"[phongLighting]"," - for lighting calculated in the fragment shader")),(0,a.kt)("h4",{id:"fp64"},"fp64"),(0,a.kt)("p",null,'The fp64 shader math library can be used leveraged by developers to conduct numerical computations that requires high numerical accuracy. This shader math library uses "multiple precision" algorithms to emulate 64-bit double precision floating point numbers, with some limitations, using two 32-bit single precision floating point numbers. To use it, just set the "fp64" key to "true" when calling ',(0,a.kt)("inlineCode",{parentName:"p"},"assembleShaders"),'. Please refer to the "64-bit layers" section in the document for more information.'),(0,a.kt)("p",null,'Note that for geospatial projection, deck.gl v6.1 introduced a "hybrid" 32-bit projection mode that provides the precision of 64-bit projection with the performance of 32-bit calculations, so it is recommended that any use of ',(0,a.kt)("inlineCode",{parentName:"p"},"fp64")," be used for non-position-projection related use cases."),(0,a.kt)("h4",{id:"picking"},"picking"),(0,a.kt)("p",null,"Picking is supported using luma.gl ",(0,a.kt)("a",{parentName:"p",href:"https://github.com/visgl/luma.gl/blob/8.0-release/docs/api-reference/shadertools/core-shader-modules.md#picking"},"picking shader module"),"."),(0,a.kt)("h3",{id:"standard-shader-hooks"},"Standard Shader Hooks"),(0,a.kt)("p",null,"When ",(0,a.kt)("a",{parentName:"p",href:"/deck.gl/docs/developer-guide/custom-layers/subclassed-layers"},"subclassing")," an official deck.gl layer with minor feature additions, it is possible to inject custom code into predefined locations into the original shaders. These hooks are considered the public API of layers that will work consistently cross minor releases."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-js"},"const shaders = this.getShaders();\n\nconst model = new Model(gl, {\n  ...this.getShaders(),\n  inject: {\n    'fs:decl': `\n      uniform float coverage;\n    `\n    'fs:DECKGL_FILTER_COLOR': `\n      if (abs(geometry.uv.x) > coverage) discard;\n    `\n  }\n});\n")),(0,a.kt)("h5",{id:"vsdecl"},"vs:#decl"),(0,a.kt)("p",null,"Inject into the top of the vertex shader (declarations)."),(0,a.kt)("h5",{id:"vsmain-start"},"vs:#main-start"),(0,a.kt)("p",null,"Inject into the the very beginning of the main function in the vertex shader."),(0,a.kt)("h5",{id:"vsmain-end"},"vs:#main-end"),(0,a.kt)("p",null,"Inject into the the very end of the main function in the vertex shader."),(0,a.kt)("h5",{id:"vsdeckgl_filter_size"},"vs:DECKGL_FILTER_SIZE"),(0,a.kt)("p",null,"Inject into a function in the vertex shader to manipulate the size of a geometry. Called before projection."),(0,a.kt)("p",null,"Arguments:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"inout vec3 size")," - offset of the current vertex from ",(0,a.kt)("inlineCode",{parentName:"li"},"geometry.worldPosition")," in common space."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"VertexGeometry geometry")," - descriptor of the current geometry")),(0,a.kt)("h5",{id:"vsdeckgl_filter_gl_position"},"vs:DECKGL_FILTER_GL_POSITION"),(0,a.kt)("p",null,"Inject into a function in the vertex shader to manipulate the projected position of the current vertex. Called after projection."),(0,a.kt)("p",null,"Arguments:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"inout vec4 position")," - position of the current vertex in clipspace"),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"VertexGeometry geometry")," - descriptor of the current geometry")),(0,a.kt)("h5",{id:"vsdeckgl_filter_color"},"vs:DECKGL_FILTER_COLOR"),(0,a.kt)("p",null,"Inject into a function in the vertex shader to manipulate the color of the current geometry. Called after projection."),(0,a.kt)("p",null,"Arguments:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"inout vec4 color")," - color of the current geometry, RGBA in the ",(0,a.kt)("inlineCode",{parentName:"li"},"[0, 1]")," range"),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"VertexGeometry geometry")," - descriptor of the current geometry")),(0,a.kt)("h5",{id:"fsdecl"},"fs:#decl"),(0,a.kt)("p",null,"Inject into the top of the fragment shader (declarations)."),(0,a.kt)("h5",{id:"fsmain-start"},"fs:#main-start"),(0,a.kt)("p",null,"Inject into the the very beginning of the main function in the fragment shader."),(0,a.kt)("h5",{id:"fsmain-end"},"fs:#main-end"),(0,a.kt)("p",null,"Inject into the the very end of the main function in the fragment shader."),(0,a.kt)("h5",{id:"fsdeckgl_filter_color"},"fs:DECKGL_FILTER_COLOR"),(0,a.kt)("p",null,"Inject into a function in the vertex shader to manipulate the color of the current geometry. Called after projection."),(0,a.kt)("p",null,"Arguments:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"inout vec4 color")," - color of the current geometry, RGBA in the ",(0,a.kt)("inlineCode",{parentName:"li"},"[0, 1]")," range"),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"FragmentGeometry geometry")," - descriptor of the current geometry")),(0,a.kt)("h3",{id:"vertexgeometry-struct"},"VertexGeometry struct"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"vec3 worldPosition")," - The world position of the current geometry, usually populated from a ",(0,a.kt)("inlineCode",{parentName:"li"},"getPosition")," accessor."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"vec3 worldPositionAlt")," - The secondary world position of the current geometry. This property is populated if the geometry is instanced between a source position and a target position, for example ",(0,a.kt)("inlineCode",{parentName:"li"},"ArcLayer"),"."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"vec3 normal")," - The normal at the current vertex in common space. Only populated for 3D layers."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"vec2 uv")," - The uv position at the current vertex."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"vec4 position")," - The position of the current vertex in common space. Populated during projection."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"vec3 pickingColor")," - The picking color of the current vertex.")),(0,a.kt)("h3",{id:"fragmentgeometry-struct"},"FragmentGeometry struct"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"vec2 uv")," - The uv position at the current vertex.")),(0,a.kt)("h2",{id:"shader-techniques-and-ideas"},"Shader Techniques and Ideas"),(0,a.kt)("h3",{id:"filtering-and-brushing-vertex-and-fragment-shaders"},"Filtering and Brushing (Vertex and Fragment Shaders)"),(0,a.kt)("p",null,'When rendering large data sets (especially a lot of intersecting lines or arcs) it can be hard to see the structure in the data in the resulting visualization. A useful technique in these cases is to use "brushing".'),(0,a.kt)("p",null,"Sometimes, being able to filter out a specific color, or range of colors, from the data without modifying the data container itself can be helpful for performance or just code simplification reasons. This is also a feature that can easily be added to a deck.gl shader."),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Tip:")," Use ",(0,a.kt)("inlineCode",{parentName:"p"},"discard")," in the fragment shader instead of 0 alpha. Faster and leaves the depth buffer unaffected."),(0,a.kt)("h3",{id:"animation-vertex-shader"},"Animation (Vertex Shader)"),(0,a.kt)("p",null,"A powerful capability of deck.gl is to render layers with thousands of animated and/or interactive objects with the computing power of GPUs."),(0,a.kt)("p",null,"Creating an animated layer can be as easy as having the application supply start and end positions for every object, and a time interval over which to animate, and have the vertex shader interpolate the positions for every frame using a simple ",(0,a.kt)("inlineCode",{parentName:"p"},"mix")," GLSL instruction."),(0,a.kt)("h2",{id:"uniforms"},"Uniforms"),(0,a.kt)("h3",{id:"layer-prop-uniforms"},"Layer prop uniforms"),(0,a.kt)("h5",{id:"float"},(0,a.kt)("inlineCode",{parentName:"h5"},"float layerIndex")),(0,a.kt)("p",null,"The layerIndex is a small integer that starts at zero and is incremented for each layer that is rendered. It can be used to add small offsets to the z coordinate of layers to resolve z-fighting between overlapping layers."),(0,a.kt)("h5",{id:"float"},(0,a.kt)("inlineCode",{parentName:"h5"},"float opacity")),(0,a.kt)("p",null,"In the fragment shader, multiply the fragment color with the opacity uniform."),(0,a.kt)("h3",{id:"shader-module-uniforms"},"Shader Module Uniforms"),(0,a.kt)("p",null,"The luma.gl/deck.gl shader modules provide javascript functions to set their uniforms but the actual GLSL uniforms are typically considered implementation dependent. The intention is that you should use the public functions exposed by each shader module. That said, some uniforms from the ",(0,a.kt)("a",{parentName:"p",href:"/deck.gl/docs/api-reference/core/project"},(0,a.kt)("inlineCode",{parentName:"a"},"project"))," module are considered special and are documented."),(0,a.kt)("h2",{id:"remarks"},"Remarks"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("strong",{parentName:"li"},"Use With Other GLSL Code Assemblers")," - Your shader code can be run through another GLSL code assembler like ",(0,a.kt)("a",{parentName:"li",href:"https://github.com/stackgl/glslify"},"glslify")," before you pass it to ",(0,a.kt)("inlineCode",{parentName:"li"},"assembleShaders"),". This means that you are not forced to work with only luma.gl shader modules, you can use multiple techniques to organize your shader code to fit your project needs.")))}p.isMDXComponent=!0}}]);