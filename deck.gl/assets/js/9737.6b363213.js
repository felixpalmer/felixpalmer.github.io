"use strict";(self.webpackChunkproject_website=self.webpackChunkproject_website||[]).push([[9737],{55189:(t,e,n)=>{function o(t,e){const n=e?.globalFeatureId;return void 0!==n?function(t,e){const n=s(t);for(const o of n){let t=0,n=o.featureIds.value[0];for(let i=0;i<o.featureIds.value.length;i++){const s=o.featureIds.value[i];if(s!==n){if(e===o.globalFeatureIds.value[t])return r(o,t,i);t=i,n=s}}if(e===o.globalFeatureIds.value[t])return r(o,t,o.featureIds.value.length)}throw new Error(`featureId:${e} not found`)}(t,n):function(t,e){const n=s(t,e);return function(t){const e=[];for(const n of t){if(0===n.featureIds.value.length)continue;let t=0,o=n.featureIds.value[0];for(let i=0;i<n.featureIds.value.length;i++){const s=n.featureIds.value[i];s!==o&&(e.push(r(n,t,i)),t=i,o=s)}e.push(r(n,t,n.featureIds.value.length))}return e}(n)}(t,e?.type)}function i(t,e,n){switch(t.type){case"Point":return function(t,e,n){const{positions:o}=t,i=l(o,e,n);if(i.length>1)return{type:"MultiPoint",coordinates:i};return{type:"Point",coordinates:i[0]}}(t,e,n);case"LineString":return function(t,e=-1/0,n=1/0){const{positions:o}=t,i=t.pathIndices.value.filter((t=>t>=e&&t<=n));if(!(i.length>2)){return{type:"LineString",coordinates:l(o,i[0],i[1])}}const s=[];for(let r=0;r<i.length-1;r++){const t=l(o,i[r],i[r+1]);s.push(t)}return{type:"MultiLineString",coordinates:s}}(t,e,n);case"Polygon":return a(t,e,n);default:const o=t;throw new Error(`Unsupported geometry type: ${o?.type}`)}}function s(t,e){const n=[];return t.points&&(t.points.type="Point",n.push(t.points)),t.lines&&(t.lines.type="LineString",n.push(t.lines)),t.polygons&&(t.polygons.type="Polygon",n.push(t.polygons)),n}function r(t,e,n){const o=i(t,e,n),s=function(t,e=0){const n=Object.assign({},t.properties[t.featureIds.value[e]]);for(const o in t.numericProps)n[o]=t.numericProps[o].value[e];return n}(t,e),r=function(t,e=0){return t.fields&&t.fields[t.featureIds.value[e]]}(t,e);return{type:"Feature",geometry:o,properties:s,...r}}function a(t,e=-1/0,n=1/0){const{positions:o}=t,i=t.polygonIndices.value.filter((t=>t>=e&&t<=n)),s=t.primitivePolygonIndices.value.filter((t=>t>=e&&t<=n));if(!(i.length>2)){const t=[];for(let e=0;e<s.length-1;e++){const n=l(o,s[e],s[e+1]);t.push(n)}return{type:"Polygon",coordinates:t}}const r=[];for(let l=0;l<i.length-1;l++){const e=a(t,i[l],i[l+1]).coordinates;r.push(e)}return{type:"MultiPolygon",coordinates:r}}function l(t,e,n){e=e||0,n=n||t.value.length/t.size;const o=[];for(let i=e;i<n;i++){const e=Array();for(let n=i*t.size;n<(i+1)*t.size;n++)e.push(Number(t.value[n]));o.push(e)}return o}n.d(e,{K:()=>o})},18709:(t,e,n)=>{n.d(e,{f:()=>D});var o=n(1746);function i(t,e,n){const o=s(t),i=Object.keys(o).filter((t=>o[t]!==Array));return function(t,e,n){const{pointPositionsCount:o,pointFeaturesCount:i,linePositionsCount:s,linePathsCount:u,lineFeaturesCount:c,polygonPositionsCount:d,polygonObjectsCount:f,polygonRingsCount:y,polygonFeaturesCount:g,propArrayTypes:P,coordLength:m}=e,{numericPropKeys:_=[],PositionDataType:b=Float32Array,triangulate:v=!0}=n,I=t[0]&&"id"in t[0],w=t.length>65535?Uint32Array:Uint16Array,F={type:"Point",positions:new b(o*m),globalFeatureIds:new w(o),featureIds:i>65535?new Uint32Array(o):new Uint16Array(o),numericProps:{},properties:[],fields:[]},V={type:"LineString",pathIndices:s>65535?new Uint32Array(u+1):new Uint16Array(u+1),positions:new b(s*m),globalFeatureIds:new w(s),featureIds:c>65535?new Uint32Array(s):new Uint16Array(s),numericProps:{},properties:[],fields:[]},x={type:"Polygon",polygonIndices:d>65535?new Uint32Array(f+1):new Uint16Array(f+1),primitivePolygonIndices:d>65535?new Uint32Array(y+1):new Uint16Array(y+1),positions:new b(d*m),globalFeatureIds:new w(d),featureIds:g>65535?new Uint32Array(d):new Uint16Array(d),numericProps:{},properties:[],fields:[]};v&&(x.triangles=[]);for(const r of[F,V,x])for(const t of _){const e=P[t];r.numericProps[t]=new e(r.positions.length/m)}V.pathIndices[u]=s,x.polygonIndices[f]=d,x.primitivePolygonIndices[y]=d;const C={pointPosition:0,pointFeature:0,linePosition:0,linePath:0,lineFeature:0,polygonPosition:0,polygonObject:0,polygonRing:0,polygonFeature:0,feature:0};for(const p of t){const t=p.geometry,e=p.properties||{};switch(t.type){case"Point":r(t,F,C,m,e),F.properties.push(h(e,_)),I&&F.fields.push({id:p.id}),C.pointFeature++;break;case"LineString":a(t,V,C,m,e),V.properties.push(h(e,_)),I&&V.fields.push({id:p.id}),C.lineFeature++;break;case"Polygon":l(t,x,C,m,e),x.properties.push(h(e,_)),I&&x.fields.push({id:p.id}),C.polygonFeature++;break;default:throw new Error("Invalid geometry type")}C.feature++}return function(t,e,n,o){const i={shape:"binary-feature-collection",points:{...t,positions:{value:t.positions,size:o},globalFeatureIds:{value:t.globalFeatureIds,size:1},featureIds:{value:t.featureIds,size:1},numericProps:p(t.numericProps,1)},lines:{...e,positions:{value:e.positions,size:o},pathIndices:{value:e.pathIndices,size:1},globalFeatureIds:{value:e.globalFeatureIds,size:1},featureIds:{value:e.featureIds,size:1},numericProps:p(e.numericProps,1)},polygons:{...n,positions:{value:n.positions,size:o},polygonIndices:{value:n.polygonIndices,size:1},primitivePolygonIndices:{value:n.primitivePolygonIndices,size:1},globalFeatureIds:{value:n.globalFeatureIds,size:1},featureIds:{value:n.featureIds,size:1},numericProps:p(n.numericProps,1)}};i.polygons&&n.triangles&&(i.polygons.triangles={value:new Uint32Array(n.triangles),size:1});return i}(F,V,x,m)}(t,{propArrayTypes:o,...e},{numericPropKeys:n&&n.numericPropKeys||i,PositionDataType:n?n.PositionDataType:Float32Array,triangulate:!n||n.triangulate})}function s(t){const e={};for(const n of t)if(n.properties)for(const t in n.properties){const o=n.properties[t];e[t]=d(o,e[t])}return e}function r(t,e,n,o,i){e.positions.set(t.data,n.pointPosition*o);const s=t.data.length/o;c(e,i,n.pointPosition,s),e.globalFeatureIds.fill(n.feature,n.pointPosition,n.pointPosition+s),e.featureIds.fill(n.pointFeature,n.pointPosition,n.pointPosition+s),n.pointPosition+=s}function a(t,e,n,o,i){e.positions.set(t.data,n.linePosition*o);const s=t.data.length/o;c(e,i,n.linePosition,s),e.globalFeatureIds.fill(n.feature,n.linePosition,n.linePosition+s),e.featureIds.fill(n.lineFeature,n.linePosition,n.linePosition+s);for(let r=0,a=t.indices.length;r<a;++r){const i=t.indices[r],s=r===a-1?t.data.length:t.indices[r+1];e.pathIndices[n.linePath++]=n.linePosition,n.linePosition+=(s-i)/o}}function l(t,e,n,o,i){e.positions.set(t.data,n.polygonPosition*o);const s=t.data.length/o;c(e,i,n.polygonPosition,s),e.globalFeatureIds.fill(n.feature,n.polygonPosition,n.polygonPosition+s),e.featureIds.fill(n.polygonFeature,n.polygonPosition,n.polygonPosition+s);for(let r=0,a=t.indices.length;r<a;++r){const i=n.polygonPosition;e.polygonIndices[n.polygonObject++]=i;const s=t.areas[r],a=t.indices[r],l=t.indices[r+1];for(let r=0,u=a.length;r<u;++r){const i=a[r],s=r===u-1?void 0===l?t.data.length:l[0]:a[r+1];e.primitivePolygonIndices[n.polygonRing++]=n.polygonPosition,n.polygonPosition+=(s-i)/o}u(e,s,a,{startPosition:i,endPosition:n.polygonPosition,coordLength:o})}}function u(t,e,n,{startPosition:i,endPosition:s,coordLength:r}){if(!t.triangles)return;const a=i*r,l=s*r,u=t.positions.subarray(a,l),p=n[0],c=n.slice(1).map((t=>(t-p)/r)),h=(0,o.hY)(u,c,r,e);for(let o=0,d=h.length;o<d;++o)t.triangles.push(i+h[o])}function p(t,e){const n={};for(const o in t)n[o]={value:t[o],size:e};return n}function c(t,e,n,o){for(const i in t.numericProps)if(i in e){const s=e[i];t.numericProps[i].fill(s,n,n+o)}}function h(t,e){const n={};for(const o in t)e.includes(o)||(n[o]=t[o]);return n}function d(t,e){return e!==Array&&Number.isFinite(t)?e===Float64Array||Math.fround(t)!==t?Float64Array:Float32Array:Array}var f=n(15335);function y(t){let e=0;for(let n,o,i=0,s=t.length-1;i<t.length;s=i++)n=t[i],o=t[s],e+=(o[0]-n[0])*(n[1]+o[1]);return e}function g(t,e,n){e&&n&&(1===t?e.id=n.readVarint():2===t?function(t,e){const n=t.readVarint()+t.pos;for(;t.pos<n;){const n=e._keys[t.readVarint()],o=e._values[t.readVarint()];e.properties[n]=o}}(n,e):3===t?e.type=n.readVarint():4===t&&(e._geometry=n.pos))}class P{properties;extent;type;id;_pbf;_geometry;_keys;_values;static get types(){return["Unknown","Point","LineString","Polygon"]}constructor(t,e,n,o,i){this.properties={},this.extent=n,this.type=0,this.id=null,this._pbf=t,this._geometry=-1,this._keys=o,this._values=i,t.readFields(g,this,e)}loadGeometry(){const t=this._pbf;t.pos=this._geometry;const e=t.readVarint()+t.pos;let n=1,o=0,i=0,s=0;const r=[];let a;for(;t.pos<e;){if(o<=0){const e=t.readVarint();n=7&e,o=e>>3}if(o--,1===n||2===n)i+=t.readSVarint(),s+=t.readSVarint(),1===n&&(a&&r.push(a),a=[]),a&&a.push([i,s]);else{if(7!==n)throw new Error(`unknown command ${n}`);a&&a.push(a[0].slice())}}return a&&r.push(a),r}bbox(){const t=this._pbf;t.pos=this._geometry;const e=t.readVarint()+t.pos;let n=1,o=0,i=0,s=0,r=1/0,a=-1/0,l=1/0,u=-1/0;for(;t.pos<e;){if(o<=0){const e=t.readVarint();n=7&e,o=e>>3}if(o--,1===n||2===n)i+=t.readSVarint(),s+=t.readSVarint(),i<r&&(r=i),i>a&&(a=i),s<l&&(l=s),s>u&&(u=s);else if(7!==n)throw new Error(`unknown command ${n}`)}return[r,l,a,u]}_toGeoJSON(t){let e,n,o=this.loadGeometry(),i=P.types[this.type];switch(this.type){case 1:const i=[];for(e=0;e<o.length;e++)i[e]=o[e][0];o=i,t(o,this);break;case 2:for(e=0;e<o.length;e++)t(o[e],this);break;case 3:for(o=function(t){const e=t.length;if(e<=1)return[t];const n=[];let o,i;for(let s=0;s<e;s++){const e=y(t[s]);0!==e&&(void 0===i&&(i=e<0),i===e<0?(o&&n.push(o),o=[t[s]]):o&&o.push(t[s]))}return o&&n.push(o),n}(o),e=0;e<o.length;e++)for(n=0;n<o[e].length;n++)t(o[e][n],this)}1===o.length?o=o[0]:i=`Multi${i}`;const s={type:"Feature",geometry:{type:i,coordinates:o},properties:this.properties};return null!==this.id&&(s.id=this.id),s}toGeoJSON(t){if("function"==typeof t)return this._toGeoJSON(t);const{x:e,y:n,z:o}=t,i=this.extent*Math.pow(2,o),s=this.extent*e,r=this.extent*n;return this._toGeoJSON((function(t){for(let e=0;e<t.length;e++){const n=t[e];n[0]=360*(n[0]+s)/i-180;const o=180-360*(n[1]+r)/i;n[1]=360/Math.PI*Math.atan(Math.exp(o*Math.PI/180))-90}}))}}class m{version;name;extent;length;_pbf;_keys;_values;_features;constructor(t,e){this.version=1,this.name="",this.extent=4096,this.length=0,this._pbf=t,this._keys=[],this._values=[],this._features=[],t.readFields(_,this,e),this.length=this._features.length}feature(t){if(t<0||t>=this._features.length)throw new Error("feature index out of bounds");this._pbf.pos=this._features[t];const e=this._pbf.readVarint()+this._pbf.pos;return new P(this._pbf,e,this.extent,this._keys,this._values)}}function _(t,e,n){e&&n&&(15===t?e.version=n.readVarint():1===t?e.name=n.readString():5===t?e.extent=n.readVarint():2===t?e._features.push(n.pos):3===t?e._keys.push(n.readString()):4===t&&e._values.push(function(t){let e=null;const n=t.readVarint()+t.pos;for(;t.pos<n;){const n=t.readVarint()>>3;e=1===n?t.readString():2===n?t.readFloat():3===n?t.readDouble():4===n?t.readVarint64():5===n?t.readVarint():6===n?t.readSVarint():7===n?t.readBoolean():null}return e}(n)))}class b{layers;constructor(t,e){this.layers=t.readFields(v,{},e)}}function v(t,e,n){if(3===t&&n){const t=new m(n,n.readVarint()+n.pos);t.length&&e&&(e[t.name]=t)}}function I(t){const e=t.indices.length,n="Polygon";if(e<=1)return{type:n,data:t.data,areas:[[(0,o.IC)(t.data)]],indices:[t.indices]};const i=[],s=[];let r,a=[],l=[],u=0;for(let p,c,h=0;h<e;h++){c=t.indices[h]-u,p=t.indices[h+1]-u||t.data.length;const e=t.data.slice(c,p),n=(0,o.IC)(e);if(0!==n)void 0===r&&(r=n<0),r===n<0?(l.length&&(i.push(a),s.push(l)),l=[c],a=[n]):(a.push(n),l.push(c));else{const e=t.data.slice(0,c),n=t.data.slice(p);t.data=e.concat(n),u+=p-c}}return a&&i.push(a),l.length&&s.push(l),{type:n,areas:i,indices:s,data:t.data}}function w(t,e,n){e&&n&&(1===t?e.id=n.readVarint():2===t?function(t,e){const n=t.readVarint()+t.pos;for(;t.pos<n;){const n=e._keys[t.readVarint()],o=e._values[t.readVarint()];e.properties[n]=o}}(n,e):3===t?e.type=n.readVarint():4===t&&(e._geometry=n.pos))}let F,V,x,C,k,A,S;class z{properties;extent;type;id;_pbf;_geometry;_keys;_values;_geometryInfo;constructor(t,e,n,o,i,s){this.properties={},this.extent=n,this.type=0,this.id=null,this._pbf=t,this._geometry=-1,this._keys=o,this._values=i,this._geometryInfo=s,t.readFields(w,this,e)}loadGeometry(){const t=this._pbf;t.pos=this._geometry,F=t.readVarint()+t.pos,V=1,C=0,k=0,A=0,S=0;const e=[],n=[];for(;t.pos<F;)if(C<=0&&(x=t.readVarint(),V=7&x,C=x>>3),C--,1===V||2===V)k+=t.readSVarint(),A+=t.readSVarint(),1===V&&e.push(S),n.push(k,A),S+=2;else{if(7!==V)throw new Error(`unknown command ${V}`);if(S>0){const t=e[e.length-1];n.push(n[t],n[t+1]),S+=2}}return{data:n,indices:e}}_toBinaryCoordinates(t){const e=this.loadGeometry();let n;t(e.data,this);switch(this.type){case 1:this._geometryInfo.pointFeaturesCount++,this._geometryInfo.pointPositionsCount+=e.indices.length,n={type:"Point",...e};break;case 2:this._geometryInfo.lineFeaturesCount++,this._geometryInfo.linePathsCount+=e.indices.length,this._geometryInfo.linePositionsCount+=e.data.length/2,n={type:"LineString",...e};break;case 3:n=I(e),this._geometryInfo.polygonFeaturesCount++,this._geometryInfo.polygonObjectsCount+=n.indices.length;for(const t of n.indices)this._geometryInfo.polygonRingsCount+=t.length;this._geometryInfo.polygonPositionsCount+=n.data.length/2;break;default:throw new Error(`Invalid geometry type: ${this.type}`)}const o={type:"Feature",geometry:n,properties:this.properties};return null!==this.id&&(o.id=this.id),o}toBinaryCoordinates(t){if("function"==typeof t)return this._toBinaryCoordinates(t);const{x:e,y:n,z:o}=t,i=this.extent*Math.pow(2,o),s=this.extent*e,r=this.extent*n;return this._toBinaryCoordinates((t=>function(t,e,n,o){for(let i=0,s=t.length;i<s;i+=2){t[i]=360*(t[i]+e)/o-180;const s=180-360*(t[i+1]+n)/o;t[i+1]=360/Math.PI*Math.atan(Math.exp(s*Math.PI/180))-90}}(t,s,r,i)))}}class L{version;name;extent;length;_pbf;_keys;_values;_features;constructor(t,e){this.version=1,this.name="",this.extent=4096,this.length=0,this._pbf=t,this._keys=[],this._values=[],this._features=[],t.readFields(M,this,e),this.length=this._features.length}feature(t,e){if(t<0||t>=this._features.length)throw new Error("feature index out of bounds");this._pbf.pos=this._features[t];const n=this._pbf.readVarint()+this._pbf.pos;return new z(this._pbf,n,this.extent,this._keys,this._values,e)}}function M(t,e,n){e&&n&&(15===t?e.version=n.readVarint():1===t?e.name=n.readString():5===t?e.extent=n.readVarint():2===t?e._features.push(n.pos):3===t?e._keys.push(n.readString()):4===t&&e._values.push(function(t){let e=null;const n=t.readVarint()+t.pos;for(;t.pos<n;){const n=t.readVarint()>>3;e=1===n?t.readString():2===n?t.readFloat():3===n?t.readDouble():4===n?t.readVarint64():5===n?t.readVarint():6===n?t.readSVarint():7===n?t.readBoolean():null}return e}(n)))}class U{layers;constructor(t,e){this.layers=t.readFields(j,{},e)}}function j(t,e,n){if(3===t&&n){const t=new L(n,n.readVarint()+n.pos);t.length&&e&&(e[t.name]=t)}}function E(t,e){const n=function(t){if(!t?.mvt)throw new Error("mvt options required");const e="wgs84"===t.mvt?.coordinates,{tileIndex:n}=t.mvt,o=n&&Number.isFinite(n.x)&&Number.isFinite(n.y)&&Number.isFinite(n.z);if(e&&!o)throw new Error("MVT Loader: WGS84 coordinates need tileIndex property");return t.mvt}(e),o=e?.gis?.format||e?.mvt?.shape||e?.shape;switch(o){case"columnar-table":return{shape:"columnar-table",data:O(t,n)};case"geojson-table":return{shape:"geojson-table",type:"FeatureCollection",features:N(t,n)};case"geojson":return N(t,n);case"binary-geometry":case"binary":return O(t,n);default:throw new Error(o||"undefined shape")}}function O(t,e){const[n,o]=function(t,e){const n=[],o={coordLength:2,pointPositionsCount:0,pointFeaturesCount:0,linePositionsCount:0,linePathsCount:0,lineFeaturesCount:0,polygonPositionsCount:0,polygonObjectsCount:0,polygonRingsCount:0,polygonFeaturesCount:0};if(t.byteLength<=0)return[n,o];const i=new U(new f(t)),s=e&&Array.isArray(e.layers)?e.layers:Object.keys(i.layers);return s.forEach((t=>{const s=i.layers[t];if(s)for(let i=0;i<s.length;i++){const r=T(s.feature(i,o),e,t);n.push(r)}})),[n,o]}(t,e),s=i(n,o);return s.byteLength=t.byteLength,s}function N(t,e){if(t.byteLength<=0)return[];const n=[],o=new b(new f(t));return(Array.isArray(e.layers)?e.layers:Object.keys(o.layers)).forEach((t=>{const i=o.layers[t];if(i)for(let o=0;o<i.length;o++){const s=G(i.feature(o),e,t);n.push(s)}})),n}function G(t,e,n){const o=t.toGeoJSON("wgs84"===e.coordinates?e.tileIndex:B);return e.layerProperty&&(o.properties[e.layerProperty]=n),o}function T(t,e,n){const o=t.toBinaryCoordinates("wgs84"===e.coordinates?e.tileIndex:$);return e.layerProperty&&o.properties&&(o.properties[e.layerProperty]=n),o}function B(t,e){const{extent:n}=e;for(let o=0;o<t.length;o++){const e=t[o];e[0]/=n,e[1]/=n}}function $(t,e){const{extent:n}=e;for(let o=0,i=t.length;o<i;++o)t[o]/=n}const D={dataType:null,batchType:null,name:"Mapbox Vector Tile",id:"mvt",module:"mvt",version:"4.2.1",extensions:["mvt","pbf"],mimeTypes:["application/vnd.mapbox-vector-tile","application/x-protobuf"],worker:!0,category:"geometry",options:{mvt:{shape:"geojson",coordinates:"local",layerProperty:"layerName",layers:void 0,tileIndex:null}}}}}]);