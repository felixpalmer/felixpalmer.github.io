"use strict";(self.webpackChunkproject_website=self.webpackChunkproject_website||[]).push([[4584],{58853:(t,e,s)=>{s.d(e,{Z:()=>i});var n=s(95328);const r={id:"request-scheduler",throttleRequests:!0,maxRequests:6,debounceTime:0};class i{constructor(){let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};this.props=void 0,this.stats=void 0,this.activeRequestCount=0,this.requestQueue=[],this.requestMap=new Map,this.updateTimer=null,this.props={...r,...t},this.stats=new n.Z({id:this.props.id}),this.stats.get("Queued Requests"),this.stats.get("Active Requests"),this.stats.get("Cancelled Requests"),this.stats.get("Queued Requests Ever"),this.stats.get("Active Requests Ever")}scheduleRequest(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:()=>0;if(!this.props.throttleRequests)return Promise.resolve({done:()=>{}});if(this.requestMap.has(t))return this.requestMap.get(t);const s={handle:t,priority:0,getPriority:e},n=new Promise((t=>(s.resolve=t,s)));return this.requestQueue.push(s),this.requestMap.set(t,n),this._issueNewRequests(),n}_issueRequest(t){const{handle:e,resolve:s}=t;let n=!1;const r=()=>{n||(n=!0,this.requestMap.delete(e),this.activeRequestCount--,this._issueNewRequests())};return this.activeRequestCount++,s?s({done:r}):Promise.resolve({done:r})}_issueNewRequests(){null!==this.updateTimer&&clearTimeout(this.updateTimer),this.updateTimer=setTimeout((()=>this._issueNewRequestsAsync()),this.props.debounceTime)}_issueNewRequestsAsync(){null!==this.updateTimer&&clearTimeout(this.updateTimer),this.updateTimer=null;const t=Math.max(this.props.maxRequests-this.activeRequestCount,0);if(0!==t){this._updateAllRequests();for(let e=0;e<t;++e){const t=this.requestQueue.shift();t&&this._issueRequest(t)}}}_updateAllRequests(){const t=this.requestQueue;for(let e=0;e<t.length;++e){const s=t[e];this._updateRequest(s)||(t.splice(e,1),this.requestMap.delete(s.handle),e--)}t.sort(((t,e)=>t.priority-e.priority))}_updateRequest(t){return t.priority=t.getPriority(t.handle),!(t.priority<0)||(t.resolve(null),!1)}}},82654:(t,e,s)=>{s.d(e,{Bs:()=>n,H2:()=>i,KC:()=>r,VF:()=>a});const n=.1,r=1e-12,i=1e-15,a=1e-20;Math.PI,Math.PI,Math.PI,Math.PI},5044:(t,e,s)=>{s.d(e,{Xx:()=>c,KM:()=>f,Mh:()=>F,F7:()=>_,JO:()=>B,du:()=>ot});const n=-1,r=0,i=1;var a=s(4942),o=s(51394);const u=new o.P,h=new o.P;class c{constructor(t=[0,0,0],e=[0,0,0],s){(0,a.Z)(this,"center",void 0),(0,a.Z)(this,"halfDiagonal",void 0),(0,a.Z)(this,"minimum",void 0),(0,a.Z)(this,"maximum",void 0),s=s||u.copy(t).add(e).scale(.5),this.center=new o.P(s),this.halfDiagonal=new o.P(e).subtract(this.center),this.minimum=new o.P(t),this.maximum=new o.P(e)}clone(){return new c(this.minimum,this.maximum,this.center)}equals(t){return this===t||Boolean(t)&&this.minimum.equals(t.minimum)&&this.maximum.equals(t.maximum)}transform(t){return this.center.transformAsPoint(t),this.halfDiagonal.transform(t),this.minimum.transform(t),this.maximum.transform(t),this}intersectPlane(t){const{halfDiagonal:e}=this,s=h.from(t.normal),a=e.x*Math.abs(s.x)+e.y*Math.abs(s.y)+e.z*Math.abs(s.z),o=this.center.dot(s)+t.distance;return o-a>0?i:o+a<0?n:r}distanceTo(t){return Math.sqrt(this.distanceSquaredTo(t))}distanceSquaredTo(t){const e=u.from(t).subtract(this.center),{halfDiagonal:s}=this;let n,r=0;return n=Math.abs(e.x)-s.x,n>0&&(r+=n*n),n=Math.abs(e.y)-s.y,n>0&&(r+=n*n),n=Math.abs(e.z)-s.z,n>0&&(r+=n*n),r}}var l=s(86671);const m=new o.P,d=new o.P;class f{constructor(t=[0,0,0],e=0){(0,a.Z)(this,"center",void 0),(0,a.Z)(this,"radius",void 0),this.radius=-0,this.center=new o.P,this.fromCenterRadius(t,e)}fromCenterRadius(t,e){return this.center.from(t),this.radius=e,this}fromCornerPoints(t,e){return e=m.from(e),this.center=(new o.P).from(t).add(e).scale(.5),this.radius=this.center.distance(e),this}equals(t){return this===t||Boolean(t)&&this.center.equals(t.center)&&this.radius===t.radius}clone(){return new f(this.center,this.radius)}union(t){const e=this.center,s=this.radius,n=t.center,r=t.radius,i=m.copy(n).subtract(e),a=i.magnitude();if(s>=a+r)return this.clone();if(r>=a+s)return t.clone();const o=.5*(s+a+r);return d.copy(i).scale((-s+o)/a).add(e),this.center.copy(d),this.radius=o,this}expand(t){const e=m.from(t).subtract(this.center).magnitude();return e>this.radius&&(this.radius=e),this}transform(t){this.center.transform(t);const e=l.Q$(m,t);return this.radius=Math.max(e[0],Math.max(e[1],e[2]))*this.radius,this}distanceSquaredTo(t){const e=this.distanceTo(t);return e*e}distanceTo(t){const e=m.from(t).subtract(this.center);return Math.max(0,e.len()-this.radius)}intersectPlane(t){const e=this.center,s=this.radius,a=t.normal.dot(e)+t.distance;return a<-s?n:a<s?r:i}}var p=s(57588),w=s(72889);const P=new o.P,M=new o.P,g=new o.P,y=new o.P,x=new o.P,b=new o.P,q=new o.P,A=0,I=1,T=2,v=3,C=4,E=5,N=6,R=7,S=8;class _{constructor(t=[0,0,0],e=[0,0,0,0,0,0,0,0,0]){(0,a.Z)(this,"center",void 0),(0,a.Z)(this,"halfAxes",void 0),this.center=(new o.P).from(t),this.halfAxes=new p.V(e)}get halfSize(){const t=this.halfAxes.getColumn(0),e=this.halfAxes.getColumn(1),s=this.halfAxes.getColumn(2);return[new o.P(t).len(),new o.P(e).len(),new o.P(s).len()]}get quaternion(){const t=this.halfAxes.getColumn(0),e=this.halfAxes.getColumn(1),s=this.halfAxes.getColumn(2),n=new o.P(t).normalize(),r=new o.P(e).normalize(),i=new o.P(s).normalize();return(new w._).fromMatrix3(new p.V([...n,...r,...i]))}fromCenterHalfSizeQuaternion(t,e,s){const n=new w._(s),r=(new p.V).fromQuaternion(n);return r[0]=r[0]*e[0],r[1]=r[1]*e[0],r[2]=r[2]*e[0],r[3]=r[3]*e[1],r[4]=r[4]*e[1],r[5]=r[5]*e[1],r[6]=r[6]*e[2],r[7]=r[7]*e[2],r[8]=r[8]*e[2],this.center=(new o.P).from(t),this.halfAxes=r,this}clone(){return new _(this.center,this.halfAxes)}equals(t){return this===t||Boolean(t)&&this.center.equals(t.center)&&this.halfAxes.equals(t.halfAxes)}getBoundingSphere(t=new f){const e=this.halfAxes,s=e.getColumn(0,g),n=e.getColumn(1,y),r=e.getColumn(2,x),i=P.copy(s).add(n).add(r);return t.center.copy(this.center),t.radius=i.magnitude(),t}intersectPlane(t){const e=this.center,s=t.normal,a=this.halfAxes,o=s.x,u=s.y,h=s.z,c=Math.abs(o*a[A]+u*a[I]+h*a[T])+Math.abs(o*a[v]+u*a[C]+h*a[E])+Math.abs(o*a[N]+u*a[R]+h*a[S]),l=s.dot(e)+t.distance;return l<=-c?n:l>=c?i:r}distanceTo(t){return Math.sqrt(this.distanceSquaredTo(t))}distanceSquaredTo(t){const e=M.from(t).subtract(this.center),s=this.halfAxes,n=s.getColumn(0,g),r=s.getColumn(1,y),i=s.getColumn(2,x),a=n.magnitude(),o=r.magnitude(),u=i.magnitude();n.normalize(),r.normalize(),i.normalize();let h,c=0;return h=Math.abs(e.dot(n))-a,h>0&&(c+=h*h),h=Math.abs(e.dot(r))-o,h>0&&(c+=h*h),h=Math.abs(e.dot(i))-u,h>0&&(c+=h*h),c}computePlaneDistances(t,e,s=[-0,-0]){let n=Number.POSITIVE_INFINITY,r=Number.NEGATIVE_INFINITY;const i=this.center,a=this.halfAxes,o=a.getColumn(0,g),u=a.getColumn(1,y),h=a.getColumn(2,x),c=b.copy(o).add(u).add(h).add(i),l=q.copy(c).subtract(t);let m=e.dot(l);return n=Math.min(m,n),r=Math.max(m,r),c.copy(i).add(o).add(u).subtract(h),l.copy(c).subtract(t),m=e.dot(l),n=Math.min(m,n),r=Math.max(m,r),c.copy(i).add(o).subtract(u).add(h),l.copy(c).subtract(t),m=e.dot(l),n=Math.min(m,n),r=Math.max(m,r),c.copy(i).add(o).subtract(u).subtract(h),l.copy(c).subtract(t),m=e.dot(l),n=Math.min(m,n),r=Math.max(m,r),i.copy(c).subtract(o).add(u).add(h),l.copy(c).subtract(t),m=e.dot(l),n=Math.min(m,n),r=Math.max(m,r),i.copy(c).subtract(o).add(u).subtract(h),l.copy(c).subtract(t),m=e.dot(l),n=Math.min(m,n),r=Math.max(m,r),i.copy(c).subtract(o).subtract(u).add(h),l.copy(c).subtract(t),m=e.dot(l),n=Math.min(m,n),r=Math.max(m,r),i.copy(c).subtract(o).subtract(u).subtract(h),l.copy(c).subtract(t),m=e.dot(l),n=Math.min(m,n),r=Math.max(m,r),s[0]=n,s[1]=r,s}transform(t){this.center.transformAsPoint(t);const e=this.halfAxes.getColumn(0,g);e.transformAsPoint(t);const s=this.halfAxes.getColumn(1,y);s.transformAsPoint(t);const n=this.halfAxes.getColumn(2,x);return n.transformAsPoint(t),this.halfAxes=new p.V([...e,...s,...n]),this}getTransform(){throw new Error("not implemented")}}var V=s(92790),z=s(55715);const D=new o.P,Z=new o.P;class B{constructor(t=[0,0,1],e=0){(0,a.Z)(this,"normal",void 0),(0,a.Z)(this,"distance",void 0),this.normal=new o.P,this.distance=-0,this.fromNormalDistance(t,e)}fromNormalDistance(t,e){return(0,V.h)(Number.isFinite(e)),this.normal.from(t).normalize(),this.distance=e,this}fromPointNormal(t,e){t=D.from(t),this.normal.from(e).normalize();const s=-this.normal.dot(t);return this.distance=s,this}fromCoefficients(t,e,s,n){return this.normal.set(t,e,s),(0,V.h)((0,z.fS)(this.normal.len(),1)),this.distance=n,this}clone(){return new B(this.normal,this.distance)}equals(t){return(0,z.fS)(this.distance,t.distance)&&(0,z.fS)(this.normal,t.normal)}getPointDistance(t){return this.normal.dot(t)+this.distance}transform(t){const e=Z.copy(this.normal).transformAsVector(t).normalize(),s=this.normal.scale(-this.distance).transform(t);return this.fromPointNormal(s,e)}projectPointOntoPlane(t,e=[0,0,0]){const s=D.from(t),n=this.getPointDistance(s),r=Z.copy(this.normal).scale(n);return s.subtract(r).to(e)}}const K=[new o.P([1,0,0]),new o.P([0,1,0]),new o.P([0,0,1])],Q=new o.P,U=new o.P;class F{constructor(t=[]){(0,a.Z)(this,"planes",void 0),this.planes=t}fromBoundingSphere(t){this.planes.length=2*K.length;const e=t.center,s=t.radius;let n=0;for(const r of K){let t=this.planes[n],i=this.planes[n+1];t||(t=this.planes[n]=new B),i||(i=this.planes[n+1]=new B);const a=Q.copy(r).scale(-s).add(e);t.fromPointNormal(a,r);const o=Q.copy(r).scale(s).add(e),u=U.copy(r).negate();i.fromPointNormal(o,u),n+=2}return this}computeVisibility(t){let e=i;for(const s of this.planes){switch(t.intersectPlane(s)){case n:return n;case r:e=r}}return e}computeVisibilityWithPlaneMask(t,e){if((0,V.h)(Number.isFinite(e),"parentPlaneMask is required."),e===F.MASK_OUTSIDE||e===F.MASK_INSIDE)return e;let s=F.MASK_INSIDE;const i=this.planes;for(let a=0;a<this.planes.length;++a){const o=a<31?1<<a:0;if(a<31&&0==(e&o))continue;const u=i[a],h=t.intersectPlane(u);if(h===n)return F.MASK_OUTSIDE;h===r&&(s|=o)}return s}}(0,a.Z)(F,"MASK_OUTSIDE",4294967295),(0,a.Z)(F,"MASK_INSIDE",0),(0,a.Z)(F,"MASK_INDETERMINATE",2147483647);new o.P,new o.P,new o.P,new o.P,new o.P;new o.P,new o.P,new o.P,new o.P,new o.P,new o.P,new o.P,new o.P,new o.P,new o.P,new o.P,new o.P;var L=s(82654);const X=new p.V,k=new p.V,O=new p.V,j=new p.V,H=new p.V;function Y(t,e={}){const s=L.VF;let n=0,r=0;const i=k,a=O;i.identity(),a.copy(t);const o=s*function(t){let e=0;for(let s=0;s<9;++s){const n=t[s];e+=n*n}return Math.sqrt(e)}(a);for(;r<10&&W(a)>o;)$(a,j),H.copy(j).transpose(),a.multiplyRight(j),a.multiplyLeft(H),i.multiplyRight(j),++n>2&&(++r,n=0);return e.unitary=i.toTarget(e.unitary),e.diagonal=a.toTarget(e.diagonal),e}const G=[1,0,0],J=[2,2,1];function W(t){let e=0;for(let s=0;s<3;++s){const n=t[X.getElementIndex(J[s],G[s])];e+=2*n*n}return Math.sqrt(e)}function $(t,e){const s=L.H2;let n=0,r=1;for(let h=0;h<3;++h){const e=Math.abs(t[X.getElementIndex(J[h],G[h])]);e>n&&(r=h,n=e)}const i=G[r],a=J[r];let o=1,u=0;if(Math.abs(t[X.getElementIndex(a,i)])>s){const e=(t[X.getElementIndex(a,a)]-t[X.getElementIndex(i,i)])/2/t[X.getElementIndex(a,i)];let s;s=e<0?-1/(-e+Math.sqrt(1+e*e)):1/(e+Math.sqrt(1+e*e)),o=1/Math.sqrt(1+s*s),u=s*o}return p.V.IDENTITY.to(e),e[X.getElementIndex(i,i)]=e[X.getElementIndex(a,a)]=o,e[X.getElementIndex(a,i)]=u,e[X.getElementIndex(i,a)]=-u,e}const tt=new o.P,et=new o.P,st=new o.P,nt=new o.P,rt=new o.P,it=new p.V,at={diagonal:new p.V,unitary:new p.V};function ot(t,e=new _){if(!t||0===t.length)return e.halfAxes=new p.V([0,0,0,0,0,0,0,0,0]),e.center=new o.P,e;const s=t.length,n=new o.P(0,0,0);for(const o of t)n.add(o);const r=1/s;n.multiplyByScalar(r);let i=0,a=0,u=0,h=0,c=0,l=0;for(const o of t){const t=tt.copy(o).subtract(n);i+=t.x*t.x,a+=t.x*t.y,u+=t.x*t.z,h+=t.y*t.y,c+=t.y*t.z,l+=t.z*t.z}i*=r,a*=r,u*=r,h*=r,c*=r,l*=r;const m=it;m[0]=i,m[1]=a,m[2]=u,m[3]=a,m[4]=h,m[5]=c,m[6]=u,m[7]=c,m[8]=l;const{unitary:d}=Y(m,at),f=e.halfAxes.copy(d);let w=f.getColumn(0,st),P=f.getColumn(1,nt),M=f.getColumn(2,rt),g=-Number.MAX_VALUE,y=-Number.MAX_VALUE,x=-Number.MAX_VALUE,b=Number.MAX_VALUE,q=Number.MAX_VALUE,A=Number.MAX_VALUE;for(const o of t)tt.copy(o),g=Math.max(tt.dot(w),g),y=Math.max(tt.dot(P),y),x=Math.max(tt.dot(M),x),b=Math.min(tt.dot(w),b),q=Math.min(tt.dot(P),q),A=Math.min(tt.dot(M),A);w=w.multiplyByScalar(.5*(b+g)),P=P.multiplyByScalar(.5*(q+y)),M=M.multiplyByScalar(.5*(A+x)),e.center.copy(w).add(P).add(M);const I=et.set(g-b,y-q,x-A).multiplyByScalar(.5),T=new p.V([I[0],0,0,0,I[1],0,0,0,I[2]]);return e.halfAxes.multiplyRight(T),e}}}]);