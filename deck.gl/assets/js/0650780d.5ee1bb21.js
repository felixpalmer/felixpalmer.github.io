"use strict";(self.webpackChunkproject_website=self.webpackChunkproject_website||[]).push([[9157],{3905:(e,t,n)=>{n.d(t,{Zo:()=>p,kt:()=>g});var i=n(67294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);t&&(i=i.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,i)}return n}function a(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,i,r=function(e,t){if(null==e)return{};var n,i,r={},o=Object.keys(e);for(i=0;i<o.length;i++)n=o[i],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(i=0;i<o.length;i++)n=o[i],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var c=i.createContext({}),s=function(e){var t=i.useContext(c),n=t;return e&&(n="function"==typeof e?e(t):a(a({},t),e)),n},p=function(e){var t=s(e.components);return i.createElement(c.Provider,{value:t},e.children)},d="mdxType",u={inlineCode:"code",wrapper:function(e){var t=e.children;return i.createElement(i.Fragment,{},t)}},k=i.forwardRef((function(e,t){var n=e.components,r=e.mdxType,o=e.originalType,c=e.parentName,p=l(e,["components","mdxType","originalType","parentName"]),d=s(n),k=r,g=d["".concat(c,".").concat(k)]||d[k]||u[k]||o;return n?i.createElement(g,a(a({ref:t},p),{},{components:n})):i.createElement(g,a({ref:t},p))}));function g(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var o=n.length,a=new Array(o);a[0]=k;var l={};for(var c in t)hasOwnProperty.call(t,c)&&(l[c]=t[c]);l.originalType=e,l[d]="string"==typeof e?e:r,a[1]=l;for(var s=2;s<o;s++)a[s]=n[s];return i.createElement.apply(null,a)}return i.createElement.apply(null,n)}k.displayName="MDXCreateElement"},58981:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>a,default:()=>u,frontMatter:()=>o,metadata:()=>l,toc:()=>s});var i=n(87462),r=(n(67294),n(3905));const o={},a="Picking",l={unversionedId:"developer-guide/custom-layers/picking",id:"developer-guide/custom-layers/picking",title:"Picking",description:"Make sure you have read Interactivity before reading this section.",source:"@site/../docs/developer-guide/custom-layers/picking.md",sourceDirName:"developer-guide/custom-layers",slug:"/developer-guide/custom-layers/picking",permalink:"/deck.gl/docs/developer-guide/custom-layers/picking",draft:!1,editUrl:"https://github.com/visgl/deck.gl/tree/master/website/../docs/developer-guide/custom-layers/picking.md",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Layer Lifecycle",permalink:"/deck.gl/docs/developer-guide/custom-layers/layer-lifecycle"},next:{title:"Composite Layers",permalink:"/deck.gl/docs/developer-guide/custom-layers/composite-layers"}},c={},s=[{value:"How It Works",id:"how-it-works",level:2},{value:"The Color Picking Technique",id:"the-color-picking-technique",level:3},{value:"Event Propagation",id:"event-propagation",level:3},{value:"Default Handling of Pointer Events",id:"default-handling-of-pointer-events",level:3},{value:"Implementing Custom Picking",id:"implementing-custom-picking",level:2},{value:"Creating A Picking Color Attribute",id:"creating-a-picking-color-attribute",level:3},{value:"Model object creation",id:"model-object-creation",level:3},{value:"Implementing Picking in Custom Shaders",id:"implementing-picking-in-custom-shaders",level:3},{value:"Vertex Shader",id:"vertex-shader",level:4},{value:"Fragment Shader",id:"fragment-shader",level:3}],p={toc:s},d="wrapper";function u(e){let{components:t,...n}=e;return(0,r.kt)(d,(0,i.Z)({},p,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"picking"},"Picking"),(0,r.kt)("blockquote",null,(0,r.kt)("p",{parentName:"blockquote"},"Make sure you have read ",(0,r.kt)("a",{parentName:"p",href:"/deck.gl/docs/developer-guide/interactivity"},"Interactivity")," before reading this section.")),(0,r.kt)("h2",{id:"how-it-works"},"How It Works"),(0,r.kt)("h3",{id:"the-color-picking-technique"},"The Color Picking Technique"),(0,r.kt)("p",null,'Rather than doing traditional ray-casting or building octrees etc in JavaScript, deck.gl implements picking on the GPU using a technique we refer to as "color picking". When deck.gl needs to determine what is under the mouse (e.g. when the user moves or clicks the pointer over the deck.gl canvas), all pickable layers are rendered into an off-screen buffer, but in a special mode activated by a GLSL uniform. In this mode, the shaders of the core layers render picking colors instead of their normal visual colors.'),(0,r.kt)("p",null,"Each object in each layer gets its own picking color assigned. The picking color is determined using ",(0,r.kt)("a",{parentName:"p",href:"/deck.gl/docs/api-reference/core/layer#encodepickingcolor"},(0,r.kt)("inlineCode",{parentName:"a"},"layer.encodePickingColor()"))," that converts the index of a object of a given layer into a 3-byte color array (the color buffer allows us to distinguish between 16M unique colors per layer, and between 256 different layers)."),(0,r.kt)("p",null,"After the picking buffer is rendered, deck.gl looks at the color of the pixel under the pointer, and decodes it back to the index number using ",(0,r.kt)("a",{parentName:"p",href:"/deck.gl/docs/api-reference/core/layer#decodepickingcolor"},(0,r.kt)("inlineCode",{parentName:"a"},"layer.decodePickingColor()")),"."),(0,r.kt)("h3",{id:"event-propagation"},"Event Propagation"),(0,r.kt)("p",null,"Once an object is picked, deck.gl creates a ",(0,r.kt)("a",{parentName:"p",href:"/deck.gl/docs/developer-guide/interactivity#the-picking-info-object"},"picking info")," object that describes what is under the pointer."),(0,r.kt)("p",null,"The ",(0,r.kt)("a",{parentName:"p",href:"/deck.gl/docs/api-reference/core/layer#getpickinginfo"},(0,r.kt)("inlineCode",{parentName:"a"},"layer.getPickingInfo()"))," method is called first on the layer that directly rendered the picked object, to modify or add additional fields to the info."),(0,r.kt)("p",null,"The info object is then passed to the ",(0,r.kt)("inlineCode",{parentName:"p"},"getPickingInfo()")," of its parent layer, and then its grandparent, and so on. This is so that composite layers can further augment the ",(0,r.kt)("inlineCode",{parentName:"p"},"info")," object after it is processed by the picked sublayer. This allows the composite layer to hide implementation details and expose only user-friendly information."),(0,r.kt)("p",null,"When the processing chain is over, the event is invoked on the top-level layer. This means that only the top-level layer's ",(0,r.kt)("inlineCode",{parentName:"p"},"on<Event>")," callbacks are invoked, and the final picking info's ",(0,r.kt)("inlineCode",{parentName:"p"},"layer")," field will point to the top-level layer. The idea is that the user should only interface with the layer that they created, and not having to know the underlying implementation."),(0,r.kt)("p",null,"When an event fires, the callback functions are executed in the following order:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"layer.on<Event>")," (default implementation invokes ",(0,r.kt)("inlineCode",{parentName:"li"},"this.props.on<Event>"),")"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"layer.props.on<Event>")," (only if the layer method is not defined)"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"deck.props.on<Event>"))),(0,r.kt)("p",null,"If any of the callback functions return ",(0,r.kt)("inlineCode",{parentName:"p"},"true"),", the event is marked handled and the rest of the callbacks will be skipped."),(0,r.kt)("h3",{id:"default-handling-of-pointer-events"},"Default Handling of Pointer Events"),(0,r.kt)("p",null,"Whenever the pointer moves over the canvas, deck.gl performs a new picking pass, yielding a picking info object describing the result. This object is used for multiple purposes:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"The ",(0,r.kt)("inlineCode",{parentName:"li"},"onHover")," callbacks are called with it"),(0,r.kt)("li",{parentName:"ul"},"To update the picked layer if ",(0,r.kt)("a",{parentName:"li",href:"/deck.gl/docs/api-reference/core/layer#autohighlight-boolean-optional"},"autoHighlight")," is enabled"),(0,r.kt)("li",{parentName:"ul"},"Saved for later use")),(0,r.kt)("p",null,"When other gestures (click, drag, etc.) are detected, deck.gl does not repeat picking. Instead, their callbacks are called with the last picked info from ",(0,r.kt)("inlineCode",{parentName:"p"},"hover"),"."),(0,r.kt)("h2",{id:"implementing-custom-picking"},"Implementing Custom Picking"),(0,r.kt)("blockquote",null,(0,r.kt)("p",{parentName:"blockquote"},'While deck.gl allows applications to implement picking however they want,\nspecial support is provided for the built-in "picking color" based picking\nsystem, which most layers use.')),(0,r.kt)("p",null,"To take full control of picking, a layer need to take the following steps:"),(0,r.kt)("h3",{id:"creating-a-picking-color-attribute"},"Creating A Picking Color Attribute"),(0,r.kt)("p",null,"Add an attribute for each vertex using the layer's ",(0,r.kt)("a",{parentName:"p",href:"/deck.gl/docs/api-reference/core/attribute-manager"},"AttributeManager"),":"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"import GL from '@luma.gl/constants';\n\nclass MyLayer extends Layer {\n  initializeState() {\n    this.state.attributeManager.add({\n      customPickingColors: {\n        size: 3,\n        type: GL.UNSIGNED_BYTE,\n        update: this.calculatePickingColors\n      }\n    });\n  }\n}\n")),(0,r.kt)("p",null,"Populate the attribute by providing a different picking color for every object that you need to differentiate. The default implementation of ",(0,r.kt)("a",{parentName:"p",href:"/deck.gl/docs/api-reference/core/layer#encodepickingcolor"},(0,r.kt)("inlineCode",{parentName:"a"},"layer.encodePickingColor()"))," and ",(0,r.kt)("a",{parentName:"p",href:"/deck.gl/docs/api-reference/core/layer#decodepickingcolor"},(0,r.kt)("inlineCode",{parentName:"a"},"layer.decodePickingColor()"))," is likely sufficient, but you may need to implement your own pair."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"class MyLayer extends Layer {\n\n  ...\n\n  calculatePickingColors(attribute) {\n      const {data} = this.props;\n      const {value} = attribute;\n\n      let i = 0;\n      for (const object of data) {\n        const pickingColor = this.encodePickingColor(i);\n        value[i * 3] = pickingColor[0];\n        value[i * 3 + 1] = pickingColor[1];\n        value[i * 3 + 2] = pickingColor[2];\n        i++;\n      }\n  }\n}\n")),(0,r.kt)("p",null,"By default, the ",(0,r.kt)("inlineCode",{parentName:"p"},"object")," field of the picking ",(0,r.kt)("inlineCode",{parentName:"p"},"info")," object is indexed from the layer's ",(0,r.kt)("inlineCode",{parentName:"p"},"data")," prop. Custom layers often need to define on their own terms what constitutes meaningful information to the user's callbacks. A layer can achieve this by overriding ",(0,r.kt)("a",{parentName:"p",href:"/deck.gl/docs/api-reference/core/layer#getpickinginfo"},(0,r.kt)("inlineCode",{parentName:"a"},"layer.getPickingInfo()"))," to add or modify fields to the ",(0,r.kt)("inlineCode",{parentName:"p"},"info")," object."),(0,r.kt)("h3",{id:"model-object-creation"},"Model object creation"),(0,r.kt)("p",null,"If your layer creates its own ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/visgl/luma.gl/blob/8.5-release/modules/engine/docs/api-reference/model.md"},"Model")," object, add picking module to ",(0,r.kt)("inlineCode",{parentName:"p"},"modules")," array."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"import {Model} from '@luma.gl/core';\nimport {picking} from '@deck.gl/core';\n\nnew Model(gl, {\n  ...\n  vs: CUSTOM_VS,\n  fs: CUSTOM_FS,\n  modules: [picking]\n});\n")),(0,r.kt)("h3",{id:"implementing-picking-in-custom-shaders"},"Implementing Picking in Custom Shaders"),(0,r.kt)("p",null,"All core layers (including composite layers) support picking using luma.gl's ",(0,r.kt)("inlineCode",{parentName:"p"},"picking module"),". If you are using custom shaders with any of the core layers or building custom layers with your own shaders, the following steps are needed to enable picking:"),(0,r.kt)("h4",{id:"vertex-shader"},"Vertex Shader"),(0,r.kt)("p",null,"Vertex shader should set current picking color using ",(0,r.kt)("inlineCode",{parentName:"p"},"picking_setPickingColor")," method provided by picking shader module."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-glsl"},"attribute vec3 customPickingColors;\n\nvoid main(void) {\n  ...\n\n  picking_setPickingColor(customPickingColors);\n}\n")),(0,r.kt)("h3",{id:"fragment-shader"},"Fragment Shader"),(0,r.kt)("p",null,"Fragment shader should use ",(0,r.kt)("inlineCode",{parentName:"p"},"picking_filterPickingColor")," to update ",(0,r.kt)("inlineCode",{parentName:"p"},"gl_FragColor"),", which outputs picking color if it is the picking pass."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-glsl"},"void main(void) {\n  ...\n\n  // Should be the last Fragment shader instruction that updates gl_FragColor\n  gl_FragColor = picking_filterPickingColor(gl_FragColor);\n}\n")),(0,r.kt)("p",null,"For more details refer to luma.gl's ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/visgl/luma.gl/blob/8.5-release/modules/shadertools/docs/api-reference/core-shader-modules.md#picking"},(0,r.kt)("inlineCode",{parentName:"a"},"Picking Module")),"."))}u.isMDXComponent=!0}}]);